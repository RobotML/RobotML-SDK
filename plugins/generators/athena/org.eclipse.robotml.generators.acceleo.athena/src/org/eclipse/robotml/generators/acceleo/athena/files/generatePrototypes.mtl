[comment encoding = UTF-8 /]
[module generatePrototypes('http://www.eclipse.org/uml2/3.0.0/UML', 'http://Papyrus/RobotML/1', 'http://www.eclipse.org/papyrus/alf/Alf')/]

[import org::eclipse::robotml::generators::acceleo::mmqueries::ArchitectureQueries /] 
[import org::eclipse::robotml::generators::acceleo::mmqueries::FSMQueries /]
[import org::eclipse::robotml::generators::acceleo::mmqueries::GeneralQueries /]
[import org::eclipse::robotml::generators::acceleo::athena::mmqueries::MMSpecificQueries /]
[import org::eclipse::robotml::generators::acceleo::alf::main::AlfServices/]

[template public generatePrototypes(model : Model)]
		
//
// Prototypes generiques
// 
[generateGenericPrototype(model)/]

//
// Prototypes specifique
//
	[for (nm : NamedElement | getModelClasses(model))]
[generatePrototype(nm.oclAsType(Class), model) /]
	[/for]
[/template]

[template private generateGenericPrototype(model : Model)]
	[let stereotypes : Sequence(String) = getStereotypeComponentUsedInModel(model)]
		[for(stereo : String | stereotypes)]
prototype [stereo/] begin
end
		[/for]
	[/let]//Property name : 
[/template]

[template public generatePrototype(class : Class, model : Model)]
[comment]If the class are an external librairy, it will be ignored[/comment]
	[if(isExternalLibrairy(class) =(false))]
// [class.name/]
		[let superClass : Class = getSuperClass(class)]
prototype [class.name/] [if((superClass = null) =(false))] is [superClass.name/][/if] begin
			[let ports : Sequence(Port) = class.eAllContents(Port)]	
				[if(ports->isEmpty() =(false))]
	[generateReferenceFromInputPort(ports, class, model)/]
	[generateParameterFromOutputPort(ports)/]
				[/if]
			[/let]		
			[let properties : Sequence(Property) = class.eAllContents(Property)]
				[if(properties->isEmpty() =(false))]
	[generateParameterFromProperties(properties)/]
	[generateInstancesFromProperties(properties)/]
				[/if]
			[/let]
			[let fsms : Sequence(StateMachine) = class.eAllContents(StateMachine)]
				[if(hasValidFSMDeclaration(class))]
	[generateFSM(fsms, model)/]
				[/if]
	[generateInteractions(fsms)/]
			[/let]
end
		[/let]
	[/if]	
[/template]

[comment]Generate the prototype's reference (input port)[/comment]
[template private generateReferenceFromInputPort(ports : Sequence(Port), class : Class, model : Model)]
[for(port : Port | ports)]
	[if(isDataFlowPort(port) and ((isAnOutputPort(port) = false) or (isAnInputOutputPort(port) = false)))]
		[if(hasComment(port))]
[getCommentFromElement(port)/]
		[/if]
[if(hasObjectInstanceConnection(model, class, port))]
reference <[port.type.name/]> @[getObjectInstanceConnectionName(model, class, port)/].[port.name/]
[elseif(hasParentInstanceConnection(model, class, port))]
reference <[port.type.name/]> @[port.name/]
[else]
//Not connected [port.name/]
[/if]
[/if]
[/for]
[/template] 

[comment]Generate the prototype's parameters (output port) [/comment]
[template private generateParameterFromOutputPort(ports : Sequence(Port))]
//Generate parameter from Output port
[for(port : Port | ports)]
[if(isDataFlowPort(port) and (isAnOutputPort(port) or isAnInputOutputPort(port)))]
[if(hasComment(port))]
[getCommentFromElement(port)/]
[/if]
[if(getInstanceMultiplicity(port) = '[]')]
parameter [port.type.name/]! [port.name/][if(hasDefaultValue(port))] = "[port.default/]"[/if]
[else]
parameter [port.type.name/] [port.name/][if(hasDefaultValue(port))] = "[port.default/]"[/if]
[/if]
[/if]
[/for]
[/template]

[comment]Generate the prototype's parameters (property)[/comment]
[template private generateParameterFromProperties(properties :Sequence(Property))]
//Generate parameter from properties
[for(prop : Property | properties)]
[if(isDataType(prop.type) and (prop.oclIsKindOf(Port) = false))]
[if(hasComment(prop))]
[getCommentFromElement(prop)/]
[/if]
[if(prop.getInstanceMultiplicity() = '[]')]
parameter [prop.type.name/]! [prop.name/][if(prop.hasDefaultValue())] = "[prop.default/]"[/if]
[else]
parameter [prop.type.name/] [prop.name/][if(prop.hasDefaultValue())] = "[prop.default/]"[/if]
[/if]
[/if]
[/for]
[/template]

[comment]Generate the prototype's instance (property)[/comment]
[template private generateInstancesFromProperties(properties : Sequence(Property))]
[for(prop : Property | properties)]
[if(isDataType(prop.type) = false)]
	[if(hasComment(prop))]
[getCommentFromElement(prop)/] 
	[/if]
instance [prop.type.name/][getInstanceMultiplicity(prop)/] [prop.name/]
[/if]
[/for]
[/template]

[comment]Generate the prototype's statemachine declaration[/comment]
[template private generateFSM(fsms : Sequence(StateMachine), model : Model)]
	[for (sm : StateMachine | fsms)]
	//[sm.name/]
[generateFSMGuard(sm, model)/]
[generateFSMEffect(sm)/]
[let states : Sequence(Vertex) = getFSMStates(sm)]
stateset [sm.name/] { [for(state : Vertex | states)][state.name/][if(states->indexOf(state) < states->size())], [/if][/for] } = [for(state : Vertex | states)][if(isStartingState(state))][state.name/][/if][/for] begin
[/let]
[let transitions : Sequence(RobotML::Transition) = getTransitions(sm)]
[for(transition : RobotML::Transition | transitions)]
[if((transition.guard = null) =(false))]
[if((transition.effect = null) = (false))]
	transition from [transition.base_Transition.source.name/] to [transition.base_Transition.target.name/] on [transition.guard.base_Operation.name/] raise [transition.effect.base_Operation.name/]
[else]
	transition from [transition.base_Transition.source.name/] to [transition.base_Transition.target.name/] on [transition.guard.base_Operation.name/]
[/if]
[/if]
[/for]
[/let]
end
	[/for]
[/template]

[comment]Generate prototype's interactions[/comment]
[template private generateInteractions(fsms : Sequence(StateMachine))]
[for(sm : StateMachine | fsms)]
[let objs : Sequence(Vertex) = getStates(sm)]
[for(obj : Vertex | objs)]
[let str : String = generateOperationStateString(obj)]
//[str/]
[if((str='') =(false))]
when ( [sm.name/]::[obj.name/] ) begin
	[str/]
end
[/if]
[/let]
[/for]			
[/let]
[/for]
[/template]

[template private generateFSMGuard(fsm : StateMachine, model : Model)]
[let transitions : Sequence(RobotML::Transition) = getTransitions(fsm)]
[for(transition : RobotML::Transition | transitions)]
[let guard : RobotML::Algorithm = transition.guard]
[if((guard = null) =(false))]
[let behaviors : Sequence(OpaqueBehavior) = getFSMOpaqueBehavior(model, fsm)]
[for( behavior : OpaqueBehavior | behaviors)]
[if((behavior.specification = null) =(false))]
[if(behavior.specification.name.equalsIgnoreCase(guard.base_Operation.name))]
[if(canConvertToAlfBlock(behavior.oclAsType(NamedElement)) = true)]
[let bloc : alf::Block = createAlfBlockFromUML(behavior.oclAsType(NamedElement))]
event [guard.base_Operation.name/] { [translateAlfBlocTo_Athena(bloc)/] }
[/let]
[else]
event [guard.base_Operation.name/] {  [behavior._body/] }
[/if]
[/if]
[/if]
[/for] 
[/let]
[/if]
[/let]
[/for]
[/let]
[/template]

[template private generateFSMEffect(fsm : StateMachine)]
[let transitions : Sequence(RobotML::Transition) = getTransitions(fsm)]
[for(transition : RobotML::Transition | transitions)]
[let effect : RobotML::Algorithm = transition.effect]
[if((effect = null) =(false))] 
signal [effect.base_Operation.name/]			
[/if]		
[/let]
[/for]
[/let]
[/template]
