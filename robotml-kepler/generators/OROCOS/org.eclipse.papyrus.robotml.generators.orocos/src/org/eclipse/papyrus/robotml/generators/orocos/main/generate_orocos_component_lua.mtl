[comment encoding = UTF-8 /]
[module generate_orocos_component_lua('http://www.eclipse.org/uml2/3.0.0/UML','http://Papyrus/RobotML/1')]
[import org::eclipse::papyrus::robotml::generators::orocos::mmqueries::OrocosQueries/]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::DataTypeQueries /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::ArchitectureQueries /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::GeneralQueries /]

[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_Datatype_file /]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_FSM /]

[template public generateOrocosComponentLua(c : Class, root_model : Model)]
[generate_Datatype_file(c, root_model)/]


[for (b : Behavior | c.ownedBehavior )]
	[if (b.isFSM())]
	[let sm : StateMachine = b.oclAsType(StateMachine)]
	[generateFSM(root_model, c,sm)/]
	[/let]
	[/if]
[/for]

[file ( 'src/'+c.name+'/'+c.name+'.lua', false, 'UTF-8')]
[comment Library declaration/]----- Library -----
require "rttlib"
require "rttros"
require "rfsm"
require "rfsm_rtt"
require "rfsmpp"

[comment Variable declaration/]----- Init local variables -----
[for (state : StateMachine | getStateMachines(c))]
local [state.name/]
[/for]
[comment]
//Libraries related to source components
[for(p : Port | getInputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
#include "../DataTypes/[t.name/].hpp"
	[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
	[/if]
[elseif (isPrimitiveType(t) and ((isActuator(p1.class)=true) or (isSensor(p1.class) = true)))]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[/if]
[/for]
[/if]

[/let]
[/for]
[/comment]
[let elt : Element = c.oclAsType(Element)]

[for (p : Port | getInputPortsForElement(elt))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
[p.name/] = rtt.InputPort([t.qualifiedName.replaceAll('::', '/')/])
	[else]
[p.name/]= rtt.InputPort([t._package.name.replace('_datatypes', '_msgs')+'/'+t.name/])
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(p1.class)=true) or (isSensor(p1.class) = true))]
[p.name/]= rtt.InputPort([t._package.name.replace('_datatypes', '_msgs')+'/'+t.name/])
[else]
[p.name/]= rtt.InputPort([t.name/])
[/if]
[else]
[p.name/]= rtt.InputPort([t._package.name.replace('_datatypes', '_msgs')+'/'+t.name/])
[/if]
[/for]
[/if]
[/let]
[/for]

[for (p : Port | getOutputPortsForElement(elt))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
[p.name/] = rtt.OutputPort([t.qualifiedName.replace('::', '/')/])
	[else]
[p.name/]= rtt.OutputPort([t._package.name.replace('_datatypes', '_msgs')+'/'+t.name/])
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(p1.class)=true) or (isSensor(p1.class) = true))]
[p.name/]= rtt.OutputPort([t._package.name.replace('_datatypes', '_msgs')+'/'+t.name/])
[else]
[p.name/]= rtt.OutputPort([t.name/])
[/if]
[else]
[p.name/]= rtt.OutputPort([t._package.name.replace('_datatypes', '_msgs')+'/'+t.name/])
[/if]
[/for]
[/if]
[/let]		
[/for]
[/let]


[comment Port declaration/]

[comment]
----- Ports -----
[let elt : Element = c.oclAsType(Element)]
 	[for (port : Port | getInputPortsForElement(elt))]
[port.name/] = rtt.InputPort("[getLUAType(port.type)/]")			
 	[/for]
  	[for (port : Port | getOutputPortsForElement(elt))]
[port.name/] = rtt.OutputPort("[getLUAType(port.type)/]")		
	[/for]
[/let]
[/comment]

[let elt : Element = c.oclAsType(Element)]
	[for (port : Port | getAllPorts(elt))]
rtt.getTC():addPort([port.name/], "[port.name/]", "A [getNameType(port.type)/] Port in Component [c.name/]");	
	[/for]
[/let]

[comment Property declaration/]----- Property -----
[let elt : Element = c.oclAsType(Element)]
[for (property : Property | getProperties(c, elt))]
[if(isRobotMLDataType(root_model, type.name))]
[property.name/] = rtt.Property("[getLUAType(property.type)/]");
[else]
[property.name/] = rtt.Property("[getNameType(property.type)/]");
[/if]
rtt.getTC():addProperty([property.name/], "[property.name/]", " A [getNameType(property.type)/] Property in Component [c.name/]/] ")
 	[/for]
 [/let]

[comment Operation declaration/]----- Operation ----- 
 
function configureHook()        
	-----configure fsm-----
	[for (state : StateMachine | getStateMachines(c))]
	[state.name/] = rfsm.init(rfsm.load("[state.name/].lua"))
	--~ [state.name/].dbg=rfsmpp.gen_dbgcolor()
	[/for]
    return true
end
 
function updateHook()
    -----start fsm-----
	[for (state : StateMachine | getStateMachines(c))]
    rfsm.run([state.name/])
	[/for]
end

function cleanupHook()
    -----cleanup ports-----
[let elt : Element = c.oclAsType(Element)]
	[for (port : Port | getAllPorts(elt))]
	rtt.getTC():removePort([port.name/]:info().name)
	[/for]
[/let]
[let elt : Element = c.oclAsType(Element)]
	[for (port : Port | getAllPorts(elt))]
	[port.name/]:delete()	
	[/for]
[/let]
end

function stopHook()
end

[/file]

[/template]