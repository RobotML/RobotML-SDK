[comment encoding = UTF-8 /]
[module generate_orocos_component_hpp('http://www.eclipse.org/uml2/3.0.0/UML')]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::ArchitectureQueries /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::DataTypeQueries /]
[import org::eclipse::papyrus::robotml::generators::orocos::mmqueries::OrocosQueries/]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_orocos_interface_hpp /]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_FSM/]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_Datatype_file /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::GeneralQueries /]

[template public generateOrocosComponentHpp(c : Class, root_model : Model)]
[file ( 'src/'+c.name+'/'+c.name+'.hpp', false, 'UTF-8')]
#include <rtt/TaskContext.hpp>
#include <ocl/Component.hpp>
#include <rtt/Port.hpp>
#include <iostream>
#include <numeric>
#include <string>
#include "../DataTypes/CppDataTypes.hpp"

//Libraries related to source components
[for(p : Port | getInputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
#include "../DataTypes/[t.name/].hpp"
	[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
	[/if]
[elseif (isPrimitiveType(t) and ((isActuator(p1.class)=true) or (isSensor(p1.class) = true)))]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[/if]
[/for]
[/if]

[/let]
[/for]

//Libraries related to target components
[for(p : Port | getOutputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
#include "../DataTypes/[t.name/].hpp"
	[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
	[/if]
[elseif (isPrimitiveType(t) and ((isActuator(p1.class)=true) or (isSensor(p1.class) = true)))]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[/if]
[/for]
[/if]

[/let]
[/for]
//Libraries related to parameters
[let elt : Element = c.oclAsType(Element)]
[for (sp : Port | getServicePort(elt))]				
[let interface : Interface = sp.type]
[for (op : Operation |getOperations(interface))]
		[for (input: Element | op.ownedParameter)]
			[let p : Parameter = input]
			[let paramType : Type = p.type]
[if((isPrimitiveType(paramType) = false) and (alreadyDefinedDataType(paramType.qualifiedName, root_model) = true))]
#include "../DataTypes/[paramType.name/].hpp"
			[/if]
			[/let]
			[/let]
		[/for]
    [/for]
[/let]
[/for]
[/let]

[comment importing interfaces/]
//interface import
[for (elt : Element | getDataTypesInElement(c))]
[let type: Type = elt]
		[if (isInterface(type))]
		#include "../[type.name+'/Task'+type.name/].hpp"
		[/if]
[/let]
[/for]

#include <stdlib.h>
#include <math.h>

using namespace std;
using namespace RTT;

[generate_Datatype_file(c, root_model)/]
[let nspace : String = c.qualifiedName.substitute('::'+c.name,'')]
[let nameSpace : Sequence(String) = nspace.tokenize('::')]
[for(s : String | nameSpace)]
namespace [s/]{
[/for]
[/let]
[/let]
class [c.name/]: public RTT::TaskContext
{   [comment ports and services declaration/]

[comment generating interfaces/]
[let elt : Element = c.oclAsType(Element)]
[for (sp : Port | getServicePort(elt))]				
[let interface : Interface = sp.type]
[generateOrocosInterfaceHpp(interface, root_model)/]
[/let]
[/for]
[/let]


[let elt : Element = c.oclAsType(Element)]
[for (sp : Port | getServicePort(elt))]				
[let interface : Interface = sp.type]
[for (op : Operation | interface.getAllOperations())]
[if (isARequiredPort(sp))]
[comment checking the return type/]

	[if (op.type <> null)]	
RTT::OperationCaller <
		[if(isPrimitiveType(op.type))]
			[if(op.type.name.equalsIgnoreCase('boolean'))]
bool 
			[else]
[op.type.name/]
			[/if]
		[else]
[op.type.qualifiedName/]
		[/if]
	[else]
RTT::OperationCaller <void
	[/if]
[comment checking the input parameters/]
[if(hasInputParameters(op) = true)]
(
		[if(getFirstInputParameter(op) <> null)]
			[let paramType : Type = getFirstInputParameter(op).type]
				[if(isPrimitiveType(paramType))]
				[if(paramType.name.equalsIgnoreCase('boolean'))]
bool [getFirstInputParameter(op).name/]
				[else]
[paramType.name/] [getFirstInputParameter(op).name/]
				[/if]
				[else]
				[paramType.qualifiedName/] [getFirstInputParameter(op).name/]
				[/if]
			[/let]
			[for (input: Element | getOperationInputParameters(op))]
				[let p : Parameter = input]
				[let paramType : Type = p.type]
					[if(isPrimitiveType(paramType))]
					[if(paramType.name.equalsIgnoreCase('boolean'))]
,bool [p.name/]
					[else]
,[paramType.name/] [p.name/]
					[/if]
					[else]
,[paramType.qualifiedName/] [p.name/]
					[/if]
				[/let]
				[/let]
			[/for]
		[/if]
[/if]
[comment checking the output parameters/]
[if(hasOutputParameters (op) = true)]
[if(hasInputParameters(op) = true)]
	[for (output: Element | getOperationOutputParameters(op))]
		[let p : Parameter = output]
		[let paramType : Type = p.type]
		[if(isPrimitiveType(paramType))]
			[if(paramType.name.equalsIgnoreCase('boolean'))]
,bool &[p.name/]
			[else]
,[paramType.name/] &[p.name/]
			[/if]
		[else]
,[paramType.qualifiedName/] &[p.name/]
		[/if]
		[/let]
		[/let]
	[/for]
[elseif (hasInputParameters(op) = false)]
	[if(getFirstOutputParameter(op) <> null)]
(
	[let paramType : Type = getFirstOutputParameter(op).type]
			[if(isPrimitiveType(paramType))]
				[if(paramType.name.equalsIgnoreCase('boolean'))]
bool [getFirstOutputParameter(op).name/]
				[else]
[paramType.name/] [getFirstOutputParameter(op).name/]
				[/if]
			[else]
[paramType.qualifiedName/] [getFirstOutputParameter(op).name/]
			[/if]
	[/let]
	[for (output: Element | getOtherOutputParameters(op))]
		[let p : Parameter = output]
		[let paramType : Type = p.type]
		[if(isPrimitiveType(paramType))]
			[if(paramType.name.equalsIgnoreCase('boolean'))]
,bool &[p.name/]
			[else]
,[paramType.name/] &[p.name/]
			[/if]
		[else]
,[paramType.qualifiedName/] &[p.name/]
		[/if]
		[/let]
		[/let]
	[/for]
	[/if]
[/if]
[/if]
[if((hasOutputParameters(op) = false) and (hasInputParameters(op) = false))]
(void
[/if]
)>[interface.name/]_[op.name/];
[/if]
[/for]
[/let]
[/for]				
[/let]


//input ports
[for(p : Port | getInputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
[p.visibility/]: InputPort<[t.qualifiedName/]> [p.name/];
	[else]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(p1.class)=true) or (isSensor(p1.class) = true))]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[else]
[p.visibility/]: InputPort<[t.name/]> [p.name/];
[/if]
[else]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[/if]
[/for]
[/if]

[/let]
[/for]

//Output ports
[for(p : Port | getOutputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
[p.visibility/]: OutputPort<[t.qualifiedName/]> [p.name/];
	[else]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(p1.class)=true) or (isSensor(p1.class) = true))]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[else]
[p.visibility/]: OutputPort<[t.name/]> [p.name/];
[/if]
[else]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[/if]
[/for]
[/if]

[/let]
[/for]

	[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
             public: Task[interface.name/]* task[interface.name/];
				[/if]
		[/let]
[/for]
	
	[comment constructor/]// Constructor
	[c.visibility/]: [c.name/] (const std::string& name)
		: [comment]
		[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
             Task[interface.name/]((std::string&)"[interface.name/]"),
				[/if]
		[/let]
		[/for] 
		[/comment]

		TaskContext(name) 							
		[let elt : Element = c.oclAsType(Element)]
		[for (port : Port | getAllPorts(elt))]
			, [port.name/]("[port.name/]")	
		[/for]
		[/let]
		[for (sp : Port | getServicePort())]				
			[let interface : Interface = sp.type]
				[for (op : Operation | interface.getAllOperations())]
					[if (isARequiredPort(sp))]
			, [interface.name/]_[op.name/] ("[interface.name/]_[op.name/]")
					[/if]
       			[/for]
			[/let]				
		[/for]	
  		{ 	
		[comment adding ports to the constructor/]
		[let elt : Element = c.oclAsType(Element)]
			[for (port : Port | getAllPorts(elt))]
		this->ports()->addPort([port.name/]);	
			[/for]
		[/let]

		[comment Subcomponents must be handled differently in Orocos/]
		[comment]
		[for ( property1: Property | getAllSubComponentsInClass(c))]
			[if (not isActuator(getclass(property1))) and (not isSensor(getclass(property1)))]
		this->addProperty("[property1.type.name.toLower()/]", [property1.type.name.toLower()/]).doc("Description :  [property1.type.name.toUpperFirst()/]") ;	
			[/if]
		[/for]
		[/comment]
		[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
        task[interface.name/] = new Task[interface.name/](this);
				[/if]
		[/let]
		[/for]
		[comment adding Properties to the constructor /]	
		[let elt : Element = c.oclAsType(Element)]
			[for (property : Property | getProperties(c,elt))]
		this->addProperty("[property.name/]", [property.name/]);
			[/for]
		[/let]

[comment adding operations to the constructor /]	
	[for (op : Operation | c.getAllOperations())]
		this->addOperation("[interface.name/]_[op.name/]", &[c.name/]::[op.name/], this, RTT::ClientThread)[getOperationSignatureName(op)/]
			.doc("Description : [op.type.name.toUpper()/]");
		[/for]

        [let elt : Element = c.oclAsType(Element)]
			[for (sp : Port | getServicePort())]				
				[let interface : Interface = sp.type]
					[for (op : Operation | interface.getAllOperations())]
						[if (isARequiredPort(sp))]
		this->requires("Task[interface.name/]")
			->addOperationCaller([interface.name/]_[op.name/]);
						[/if]
       				[/for]
				[/let]				
			[/for]
		[/let]
	}
	[comment destructor/]// Destructor
    ~[c.name/]() {
		[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
        delete task[interface.name/];
				[/if]
		[/let]
		[/for]
	}
	[comment components methods/]
	/**
	 * This function is for the configuration code.
     * Return false to abort configuration.
     */
	bool configureHook() {
			[for (sp : Port | getServicePort())]				
			[let interface : Interface = sp.type]
				[if (isARequiredPort(sp))]

[comment]
					[let p : Port = getOppositePort(sp)]
		if (!(requires("[interface.name/]")->connectTo(getPeer("[p.class.name/]")->provides("[interface.name/]")))){
			log(Info) << "connection problem to service" << endlog();
		}
					[/let]
[/comment]

				[/if]
			[/let]				
		[/for]
		// ...
		return true;
	}

	/**
	 * This function is for the application's start up code.
	 * Return false to abort start up.
	 */
	bool startHook() {
		// ...
		return true;
	}

	/**
	 * This function is called by the Execution Engine.
	 */
	void updateHook() {
		// algorithm goes here.
	}

	/**
	 * This function is called when the task is stopped.
 	 */
	void stopHook() {
		// stop code after last updateHook()
	}

	/**
	 * This function is called when the task is being deconfigured.
	 */
	void cleanupHook() {
		// Your configuration cleanup code
	}	
};

[let nspace : String = c.qualifiedName.substitute('::'+c.name,'')]
[let nameSpace : Sequence(String) = nspace.tokenize('::')]
[for(s : String | nameSpace)]
}
[/for]
[/let]
[/let]
[/file]

[/template]