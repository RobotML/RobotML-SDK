[comment encoding = UTF-8 /]
[module CPPObjectHeader('http://www.xtext.org/AthenaDSL')/]

[import org::eclipse::robotml::generators::xtext::athena::simu::main::jqueries /]

[template public CPPObjectHeader(project : Project)]
[for (proto : prototypeDeclaration | project.prototypes)]
[let fname : String = getPrototypeFileName(proto,'.h')] 
[file (fname, false, 'UTF-8')] 
[generatePrototypeHeader(project, proto)/]
[/file]
[/let]
[/for]
	
[/template]

[template private generatePrototypeHeader(project : Project, proto : prototypeDeclaration)]
#ifndef _[proto.name/]_h_
#define _[proto.name/]_h_

// Include files
#include <string>
#include <boost/function.hpp>
#include "PredefinedTypes.h"
#include "TypeDefs.h"
#include "AthenaComponent.h" 
#include "Connector.h"
#include "ParameterTemplate.h"

// Namespace
namespace generated {
using namespace generated;
using namespace AthenaV3;

//----------------------------------------------------------------
// Definition
//----------------------------------------------------------------

class [proto.name/] : public AthenaComponent 
{
[generateReferences(project, proto)/]
[generateParameters(project, proto)/]
[generateSignals(project, proto)/]
[generateEvents(project, proto)/]
[generateStateSets(project, proto)/]
[generateInteractions(project, proto)/]

// ---------------------------- GENERAL ------------------------------------
public:
	[proto.name/](XmlNode* config);
	virtual ~[proto.name/]();
	virtual void doInit();
	virtual void doConnect();
	virtual void doStep(const long& icycle);
}
#endif /* _[proto.name/]_h_ */
[/template]

[template private generateReferences(project : Project, current_proto : prototypeDeclaration)]
[let refs : Sequence(referenceDeclaration) = getReferences(project, current_proto)]
[if(refs->isEmpty() = false)]
// ---------------------------- REFERENCES ------------------------------------
private:
[for(ref : referenceDeclaration | refs)]
	IParameter<[ref.typeName.name/]>* [getReferenceName(ref)/];
	const [ref.typeName.name/]& get_[getReferenceName(ref)/](const long& icycle);
	[ref.typeName.name/]& get_[getReferenceName(ref)/]_write(const long& icycle);
	void set_[getReferenceName(ref)/](const long& icycle, const [ref.typeName.name/]& data);
[/for]
[/if]
[/let]
[/template]

[template private generateParameters(project : Project, current_proto : prototypeDeclaration)]
[let params : Sequence(parameterDeclaration) = getParameters(project, current_proto)]
[if(params->isEmpty() = false)]
// ---------------------------- PARAMETERS ------------------------------------
[for(param : parameterDeclaration | params)]
private:
[if (isArrayType(param.typeName))]
[if (isDynamicArray(param.typeName.oclAsType(arrayType)))]
	ArrayParameter<[param.typeName.name/]> [param.name/] ;
[else]
	PointerParameter<[param.typeName.name/]> [param.name/] ;
[/if]
[else]
	ConcreteParameter<[param.typeName.name/]> [param.name/];		
[/if]
public:
	IParameter<[param.typeName.name/]>* get_[param.name/]()  { return &[param.name/]; }
	const [param.typeName.name/]& get_[param.name/](const long& icycle)  { return [param.name/].getRead(icycle); }
	[param.typeName.name/]& get_[param.name/]_write(const long& icycle)  { return [param.name/].getWrite(icycle); }
	void set_[param.name/](const long& icycle, const [param.typeName.name/]& data) { [param.name/].write(icycle,data); }
[/for]
[/if]
[/let]
[/template]

[template private generateSignals(project : Project, current_proto : prototypeDeclaration)]
[let signals : Sequence(signalDeclaration) = getSignals(project, current_proto)]
[if(signals->isEmpty() = false)]
// ---------------------------- SIGNALS ------------------------------------
private:
[for(signal : signalDeclaration | signals)]
	Signal [signal.name/];
[/for]
[/if]
[/let]
[/template]

[template private generateEvents(project : Project, current_proto : prototypeDeclaration)]
[let events : Sequence(eventDeclaration) = getEvents(project, current_proto)]
[if(events->isEmpty() = false)]
// ---------------------------- EVENTS ------------------------------------
private:
[for(event : eventDeclaration | events)]
 bool event_[event.name/](const long& icycle);
[/for]
[/if]
[/let]
[/template]

[template private generateStateSets(project : Project, current_proto : prototypeDeclaration)]
[let statesets : Sequence(statesetDeclaration) = getStateSets(project, current_proto)]
[if(statesets->isEmpty() = false)]
// ---------------------------- STATESETS ------------------------------------
private:
[for(stateset : statesetDeclaration | statesets)]
	enum stateset_[stateset.name/] { [getStateSetStates(stateset)/] }; 
	ConcreteParameter<stateset_[stateset.name/]> [stateset.name/] ;
	stateset_[stateset.name/] get_[stateset.name/](const long& icycle) { return [stateset.name/].getRead(icycle); }
[/for]
[/if]
[/let]
[/template]

[template private generateInteractions(project : Project, current_proto : prototypeDeclaration)]
[let interactions : Sequence(interactionDeclaration) = getInteractions(project, current_proto)]
[if(interactions->isEmpty() = false)]
// ---------------------------- INTERACTIONS ------------------------------------
private:
[for(interaction : interactionDeclaration | interactions)]
[for (call : interactionCall | interaction.icalls)]
	void interaction_[call.fctName.name/](const long& icycle);
	boost::function<void ([getFunctorDeclaration(call.fctName)/])> _[call.fctName.name/];
[/for]
[/for]
[/if]
[/let]
[/template]
