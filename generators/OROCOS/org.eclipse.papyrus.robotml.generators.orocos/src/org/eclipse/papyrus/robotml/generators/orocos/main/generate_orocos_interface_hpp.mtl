[comment encoding = UTF-8 /]
[module generate_orocos_interface_hpp('http://www.eclipse.org/uml2/3.0.0/UML','http://Papyrus/RobotML/1')]
[import org::eclipse::papyrus::robotml::generators::orocos::mmqueries::OrocosQueries /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::DataTypeQueries /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::GeneralQueries /]

[template public generateOrocosInterfaceHpp(i : Interface, root_model : Model)]

[file ( 'src/'+i.name+'/'+i.name+'.hpp', false, 'UTF-8')]
#ifndef __[i.name.toUpperCase()/]_hpp__
#define __[i.name.toUpperCase()/]_hpp__
#include <string>
#include <numeric>
#include "../DataTypes/CppDataTypes.hpp"
	[for (op : Operation |getOperations(i))]
		[for (input: Element | op.ownedParameter)]
			[let p : Parameter = input]
			[let paramType : Type = p.type]
[if((isPrimitiveType(paramType) = false) and (alreadyDefinedDataType(paramType.qualifiedName, root_model) = true))]
#include "../DataTypes/[paramType.name/].hpp"
			[/if]
			[/let]
			[/let]
		[/for]
    [/for]

	class [i.name/] 
	{
		[comment attribut & property declaration/]
	[for (property : Property |getProperties(i))]
    [let t :Type = property.type]
    [if(isPrimitiveType(t))]
	[if(t.name.equalsIgnoreCase('boolean'))]
		[property.visibility/]: bool [property.name/];
	[else]
		[property.visibility/]: [t.name/] [property.name/] [getInstanceMultiplicity(property)/];
	[/if]
	[else]
	 [t.name/] [property.name/];
	[/if]
	
	[comment in case of ros datatypes, uncomment]
	[if(isRobotMLDataType(m, t.name))]
	[let ne : NamedElement = t.owner]
	[property.visibility/]:	[ne.name.replace('_datatypes', '_msgs')/]::[t.name/] [property.name/] [getInstanceMultiplicity(property)/];
	[/let]
	[else]
	[t.name/] [property.name/];
	[/comment]
		
	[/let]	
	[/for]	
  
 	[for (op : Operation |getOperations(i))]
		[if(op.type = null)] virtual void [interface.name/]_[op.name/]( [/if]		
		[let t :Type = op.type]

		[if(op.isStatic)]
	 		[if(isPrimitiveType(t))]
				[if(t.name.equalsIgnoreCase('boolean'))]
				[op.visibility/]: static bool [interface.name/]_[op.name/](
				[else]
				[op.visibility/]: static [t.name/] [interface.name/]_[op.name/](
				[/if]
			[else]
	 			[op.visibility/]: [t.name/] static [interface.name/]_[op.name/](
			[/if]

			[comment in case of ros datatypes, uncomment]
			[if(isRobotMLDataType(m, t.name))]
				[let ne : NamedElement = t.owner]
				[op.visibility/]: static [ne.name.replace('_datatypes', '_msgs')/]::[t.name/] [interface.name/]_[op.name/](
				[/let]
			[elseif(t.name.equalsIgnoreCase('invalid') or t.name.size() = 0)]
				 static void [interface.name/]_[op.name/](
			[else]
			[/if]
			[/comment]

			

		[elseif(op.isAbstract and not op.isStatic)]
			[if(isPrimitiveType(t))]
				[if(t.name.equalsIgnoreCase('boolean'))]
				[op.visibility/]: virtual bool [op.name/](
				[else]
				[op.visibility/]: virtual [t.name/] [interface.name/]_[op.name/](
				[/if]
			[else]
		 		 virtual [t.name/] [interface.name/]_[op.name/](		
			[/if]

			[comment in case of ros datatypes, uncomment]
			[if(isRobotMLDataType(m, t.name))]
				[let ne : NamedElement = t.owner]
				[op.visibility/]: virtual [ne.name.replace('_datatypes', '_msgs')/]::[t.name/] [op.name/]( 
				[/let]
			[elseif(t.name.equalsIgnoreCase('invalid') or t.name.size() = 0)]
				 virtual void [interface.name/]_[op.name/](
			[else]
		 		 virtual [t.name/] [interface.name/]_[op.name/](
			[/if]
			[/let]		
			[/comment]

			
		[else]
			[if(isPrimitiveType(t))]
				[if(t.name.equalsIgnoreCase('boolean'))]
				[op.visibility/]: virtual bool [interface.name/]_[op.name/](
				[else]
				[op.visibility/]: virtual [t.name/] [interface.name/]_[op.name/](
				[/if]
			[else]
		 		 [t.name/] [interface.name/]_[op.name/](		
			[/if]

			[comment in case of ros datatypes, uncomment]
			[if(isRobotMLDataType(m, t.name))]
				[let ne : NamedElement = t.owner]
				[op.visibility/]: virtual [ne.name.replace('_datatypes', '_msgs')/]::[t.name/] [op.name/]( 
				[/let]
			[elseif(t.name.equalsIgnoreCase('invalid') or t.name.size() = 0)]
				 virtual void [interface.name/]_[op.name/](
			[else]
		 		 virtual [t.name/] [interface.name/]_[op.name/](		
			[/comment]
			[/if]
			[/let]



				
[if(hasInputParameters(op) = true)]
[if(getFirstInputParameter(op) <> null)]
[let paramType : Type = getFirstInputParameter(op).type]
			[if(isPrimitiveType(paramType))]
				[if(paramType.name.equalsIgnoreCase('boolean'))]
				bool [getFirstInputParameter(op).name/]
				[else]
				[paramType.name/] [getFirstInputParameter(op).name/]
				[/if]
			[else]
				[paramType.qualifiedName/] [getFirstInputParameter(op).name/]
			[/if]
[/let]
[for (input: Element | getOperationInputParameters(op))]
	[let p : Parameter = input]
	[let paramType : Type = p.type]
		[if(isPrimitiveType(paramType))]
			[if(paramType.name.equalsIgnoreCase('boolean'))]
			,bool [p.name/]
			[else]
			,[paramType.name/] [p.name/]
			[/if]
		[else]
			,[paramType.qualifiedName/] [p.name/]
		[/if]

		[comment in case of ros datatypes uncomment]
		[if(isRobotMLDataType(m, paramType.name))]
			[let ne : NamedElement = paramType.owner]
			,[ne.name.replace('_datatypes', '_msgs')/]::[paramType.name/] [p.name/] 
			[/let]
		[else]
			,[paramType.name/] [p.name/]
		[/comment] 

		[/let]
		[/let]
	[/for]
	[/if]
	[/if]


	[if(hasOutputParameters (op) = true)]
	[if(hasInputParameters(op) = true)]

	[for (output: Element | getOperationOutputParameters(op))]
		[let p : Parameter = output]
		[let paramType : Type = p.type]
		[if(isPrimitiveType(paramType))]
			[if(paramType.name.equalsIgnoreCase('boolean'))]
			,bool &[p.name/]
			[else]
			,[paramType.name/] &[p.name/]
		[/if]
		[else]
	 		,[paramType.qualifiedName/] &[p.name/]
		[/if]
		[comment in case of ros datatypes, uncomment]
		[if(isRobotMLDataType(m, paramType.name))]
			[let ne : NamedElement = paramType.owner]
			,[ne.name.replace('_datatypes', '_msgs')/]::[paramType.name/] &[p.name/] 
			[/let]
		[else]
	 		 ,[paramType.name/] &[p.name/]
		[/comment]
		[/let]
		[/let]
	[/for]

	[elseif (hasInputParameters(op) = false)]
	[if(getFirstOutputParameter(op) <> null)]
	[let paramType : Type = getFirstOutputParameter(op).type]
			[if(isPrimitiveType(paramType))]
				[if(paramType.name.equalsIgnoreCase('boolean'))]
				bool [getFirstOutputParameter(op).name/]
				[else]
				[paramType.name/] [getFirstOutputParameter(op).name/]
				[/if]
			[else]
				[paramType.qualifiedName/] [getFirstOutputParameter(op).name/]
			[/if]
	[/let]

	[for (output: Element | getOtherOutputParameters(op))]
		[let p : Parameter = output]
		[let paramType : Type = p.type]
		[if(isPrimitiveType(paramType))]
			[if(paramType.name.equalsIgnoreCase('boolean'))]
			,bool &[p.name/]
			[else]
			,[paramType.name/] &[p.name/]
		[/if]
		[else]
	 		,[paramType.qualifiedName/] &[p.name/]
		[/if]
		[comment in case of ros datatypes, uncomment]
		[if(isRobotMLDataType(m, paramType.name))]
			[let ne : NamedElement = paramType.owner]
			[ne.name.replace('_datatypes', '_msgs')/]::[paramType.name/] &[p.name/], 
			[/let]
		[else]
	 		 ,[paramType.name/] &[p.name/]		
		[/comment]
		[/let]
		[/let]
	[/for]
	[/if]
	[/if]
	[/if]
){}
   [/for]
};
#endif
[/file]

[file ( 'src/'+i.name+'/Task'+i.name+'.hpp', false, 'UTF-8')]
#ifndef __TASK_[i.name.toUpperCase()/]_hpp__
#define __TASK_[i.name.toUpperCase()/]_hpp__
#include <string>
#include <numeric>
#include <rtt/TaskContext.hpp>
#include <rtt/Operation.hpp>
#include"[i.name/].hpp"
[let Iname: String = i.name]
class Task[Iname/] 
		: public [Iname/]{
public:
Task[Iname/](RTT::TaskContext *tc)
{
[for (op : Operation | i.getAllOperations())]
		tc->addOperation("[Iname/]_[op.name/]", &[Iname/]::[Iname/]_[op.name/], ([Iname/]*)this, RTT::ClientThread)
.doc("Description : [op.type.name.toUpper()/]")[getOperationSignatureName(op)/];
[/for]
}
[/let]
};
#endif
[/file]
[/template]