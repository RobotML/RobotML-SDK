[comment encoding = UTF-8 /]
[module generatePrototypes('http://Papyrus/RobotML/1', 'http://www.eclipse.org/uml2/3.0.0/UML', 'http://www.eclipse.org/papyrus/alf/Alf')/]

[import org::eclipse::robotml::generators::acceleo::mmqueries::ArchitectureQueries /] 
[import org::eclipse::robotml::generators::acceleo::mmqueries::FSMQueries /]
[import org::eclipse::robotml::generators::acceleo::mmqueries::GeneralQueries /]
[import org::eclipse::robotml::generators::acceleo::athena::mmqueries::MMSpecificQueries /]
[import org::eclipse::robotml::generators::acceleo::alf::main::AlfServices/]

[template public generatePrototypes(model : Model)]
		
//
// Prototypes generiques
// 
[generateGenericPrototype(model)/]

//
// Prototypes specifique
//
	[for (nm : NamedElement | getModelClasses(model))]
[generatePrototype(nm.oclAsType(Class), model) /]
	[/for]
[/template]

[template private generateGenericPrototype(model : Model)]
	[let stereotypes : Sequence(String) = getStereotypeComponentUsedInModel(model)]
		[for(stereo : String | stereotypes)]
prototype [stereo/] begin
end
		[/for]
	[/let]
[/template]

[template public generatePrototype(class : Class, model : Model)]
[comment]If the class are an external librairy, it will be ignored[/comment]
	[if(isExternalLibrairy(class) =(false))]
// [class.name/]
		[let superClass : Class = getSuperClass(class)]
prototype [class.name/] [if((superClass = null) =(false))] is [superClass.name/][/if] begin
			[let ports : Sequence(Port) = class.eAllContents(Port)]
				[if(ports->isEmpty() =(false))]
	[generateReferenceFromInputPort(ports)/]
	[generateParameterFromOutputPort(ports)/]
				[/if]
			[/let]		
			[let properties : Sequence(Property) = class.eAllContents(Property)]
				[if(properties->isEmpty() =(false))]
	[generateParameterFromProperties(properties)/]
	[generateInstancesFromProperties(properties)/]
				[/if]
			[/let]
			[let fsms : Sequence(StateMachine) = class.eAllContents(StateMachine)]
				[if(hasValidFSMDeclaration(class))]
	[generateFSM(fsms, model)/]
				[/if]
	[generateInteractions(fsms)/]
			[/let]
end
		[/let]
	[/if]	
[/template]

[comment]Generate the prototype's reference (input port)[/comment]
[template private generateReferenceFromInputPort(ports : Sequence(Port))]
[for(port : Port | ports)]
	[if(isDataFlowPort(port.base_Port) and isAnInputPort(port.base_Port))]
		[if(hasComment(port.base_Port))]
	[getCommentFromElement(port.base_Port)/]
		[/if]
		[if(isPortConnected(port.base_Port))]
	reference < [port.base_Port.type.name/] > [port.base_Port.name/]
		[else]
	//unconnected port => [port.base_Port.name/]
		[/if]
	[/if]
[/for]
[/template] 

[comment]Generate the prototype's parameters (output port) [/comment]
[template private generateParameterFromOutputPort(ports : Sequence(Port))]
	[for(port : Port | ports)]
		[if(isDataFlowPort(port.base_Port) and isAnOutputPort(port.base_Port))]
			[if(hasComment(port.base_Port))]
	[getCommentFromElement(port.base_Port)/]
			[/if]
			[if(getInstanceMultiplicity(port.base_Port) = '[]')]
	parameter [port.base_Port.type.name/]! [port.base_Port.name/][if(hasDefaultValue(port.base_Port))] = "[port.base_Port.default/]"[/if]
			[else]
	parameter [port.base_Port.type.name/] [port.base_Port.name/][if(hasDefaultValue(port.base_Port))] = "[port.base_Port.default/]"[/if]
			[/if]
		[/if]
	[/for]
[/template]

[comment]Generate the prototype's parameters (property)[/comment]
[template private generateParameterFromProperties(properties :Sequence(Property))]
[for(prop : Property | properties)]
	[if(isDataType(prop))]
		[if(hasComment(prop))]
	[getCommentFromElement(prop)/]
		[/if]
		[if(prop.getInstanceMultiplicity() = '[]')]
	parameter [prop.type.name/]! [prop.name/][if(prop.hasDefaultValue())] = "[prop.default/]"[/if]
		[else]
	parameter [prop.type.name/] [prop.name/][if(prop.hasDefaultValue())] = "[prop.default/]"[/if]
		[/if]
	[/if]
[/for]
[/template]

[comment]Generate the prototype's instance (property)[/comment]
[template private generateInstancesFromProperties(properties : Sequence(Property))]
[for(prop : Property | properties)]
	[if(isClass(prop.type))]
		[if(hasComment(prop))]
	[getCommentFromElement(prop)/] 
		[/if]
	instance [prop.type.name/][getInstanceMultiplicity(prop)/] [prop.name/]
	[/if]
[/for]
[/template]

[comment]Generate the prototype's statemachine declaration[/comment]
[template private generateFSM(fsms : Sequence(StateMachine), model : Model)]
	[for (sm : StateMachine | fsms)]
	//[sm.name/]
[generateFSMGuard(sm, model)/]
[generateFSMEffect(sm)/]
		[let states : Sequence(Vertex) = getStates(sm)]
stateset [sm.name/] { [for(state : Vertex | states)][state.name/][if(states->indexOf(state) < states->size())], [/if][/for] } = [states->first().name/] begin
		[/let]
		[let transitions : Sequence(Transition) = getTransitions(sm)]
			[for(transition : Transition | transitions)]
				[if((transition.guard = null) =(false))]
					[if((transition.effect = null) = (false))]
transition from [transition.base_Transition.source.name/] to [transition.base_Transition.target.name/] on [transition.guard.base_Operation.name/] raise [transition.effect.base_Operation.name/]
					[else]
transition from [transition.base_Transition.source.name/] to [transition.base_Transition.target.name/] on [transition.guard.base_Operation.name/]
					[/if]
				[/if]
			[/for]
		[/let]
end
	[/for]
[/template]

[comment]Generate prototype's interactions[/comment]
[template private generateInteractions(fsms : Sequence(StateMachine))]
	[for(sm : StateMachine | fsms)]
[comment]		[if(hasValidStates(sm))][/comment]
		[let objs : Sequence(Vertex) = getStates(sm)]
			[for(obj : Vertex | objs)]
				[let str : String = generateOperationStateString(obj)]
//[str/]
					[if((str='') =(false))]
	when ( [sm.name/] :: [obj.name/] ) begin
		[str/]
	end
					[/if]
				[/let]
			[/for]			
		[/let]
	[/for]
[/template]

[template private generateFSMGuard(fsm : StateMachine, model : Model)]
	[let transitions : Sequence(Transition) = getTransitions(fsm)]
		[for(transition : Transition | transitions)]
			[let guard : Algorithm = transition.guard]
				[if((guard = null) =(false))]
					[let behaviors : Sequence(OpaqueBehavior) = getFSMOpaqueBehavior(model, fsm)]
						[for( behavior : OpaqueBehavior | behaviors)]
							[if((behavior.specification = null) =(false))]
								[if(behavior.specification.name.equalsIgnoreCase(guard.base_Operation.name))]
									[if(canConvertToAlfBlock(behavior.oclAsType(NamedElement)) = true)]
										[let bloc : alf::Block = createAlfBlockFromUML(behavior.oclAsType(NamedElement))]
event [guard.base_Operation.name/] { [translateAlfBlocTo_Athena(bloc)/] }
										[/let]
									[else]
event [guard.base_Operation.name/] {  [behavior._body/] }
									[/if]
								[/if]
							[/if]
						[/for] 
					[/let]
				[/if]
			[/let]
		[/for]
	[/let]
[/template]

[template private generateFSMEffect(fsm : StateMachine)]
	[let transitions : Sequence(Transition) = getTransitions(fsm)]
		[for(transition : Transition | transitions)]
			[let effect : Algorithm = transition.effect]
				[if((effect = null) =(false))] 
signal [effect.base_Operation.name/]			
				[/if]		
			[/let]
		[/for]
	[/let]
[/template]
