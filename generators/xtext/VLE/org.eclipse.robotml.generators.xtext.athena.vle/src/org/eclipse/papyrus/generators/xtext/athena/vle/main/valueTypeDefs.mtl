[comment encoding = UTF-8 /]
[module valueTypeDefs('http://www.xtext.org/AthenaDSL')/]

[import org::eclipse::papyrus::generators::xtext::athena::vle::main::DSLQueries /]

[template public valueTypeDefs(project : Project)]
	
[file ('generated/src/TypeDefs_Values.h', false, 'UTF-8')] 

#ifndef _TypeDefs_Values_h_
#define _TypeDefs_Values_h_

// 
// Includes ----------------------------------------------------------------------
// 

#include "TypeDefs.h"
#include <vle/value/Boolean.hpp>
#include <vle/value/Double.hpp>
#include <vle/value/Integer.hpp>
#include <vle/value/Map.hpp>
#include <vle/value/Set.hpp>
#include <vle/value/Matrix.hpp>
#include <vle/value/Table.hpp>
#include <vle/value/String.hpp>
#include <vle/value/Tuple.hpp>
#include <vle/value/Null.hpp>
#include <vle/value/User.hpp>
#include <vle/value/XML.hpp>

using namespace vle;

//
namespace generated
{

//
// Data type definitions ----------------------------------------------------------
//

	[for (type : DataType | project.types)]
// -------------------------------------------------------- [type.name/]
		[if (isBasicType(type))]
[processBasicType(type.oclAsType(basicType))/]
		[elseif (isArrayType(type))]
[processArrayType(type.oclAsType(arrayType))/]
		[elseif (isVectorType(type))] 
[processVectorType(type.oclAsType(vectorType))/]
		[elseif (isMapType(type))]
[processMapType(type.oclAsType(mapType))/]
		[elseif (isStructType(type))]
[processStructType(type.oclAsType(structType))/]
		[elseif (isDefineType(type))]
[processDefineType(type.oclAsType(defineType))/]
		[else]
///
/// ERROR [type.name/] is unrecognized by the generator - [type.eClass()/]
///
		[/if]
		
	[/for]

//
// --------------------------------------------------------------------------------
//

} // eof namespace generated

#endif


[/file]

[file ('generated/src/VLE_Pointer.hpp', false, 'UTF-8')]

#ifndef VLE_POINTER_TYPE
#define VLE_POINTER_TYPE

/*
 * Includes
 */
#include <vle/value/User.hpp>

namespace vv = vle::value;
using namespace vv;

namespace generated {

class VLE_Pointer : public User {

public:
	VLE_Pointer() : User() { _pointer = NULL; }
	VLE_Pointer(void* ptr) : User() { _pointer = ptr; }
	VLE_Pointer(const VLE_Pointer& src) : User() { _pointer = (void*)src.id(); }

	virtual size_t id() const { return (size_t)_pointer; }

	virtual Value* clone() const { return new VLE_Pointer(*this); }
	virtual void writeFile(std::ostream& /*out*/) const { }
	virtual void writeString(std::ostream& /*out*/) const { }
	virtual void writeXml(std::ostream& /*out*/) const { }
	
private:
	void* _pointer;
};

} /* generated */

#endif /* VLE_POINTER_TYPE */

[/file]

[/template]


[template public processBasicType(type : basicType)]
	[let cpp : languageDecl = getCPPLanguageDecl(type) ]
// basic type [type.name/]	
__EXPORT__ value::Value* [type.name/]_toValue(const [type.name/]& _val);
__EXPORT__ [type.name/] [type.name/]_fromValue(const value::Value* _node, const [type.name/]& _initialValue = [cpp.value/]);
	[/let]
[/template]


[template public processArrayType(array : arrayType)]
// [array.name/] is an array of [getArrayDatatypeName(array)/]
__EXPORT__ value::Value* [array.name/]_toValue(const [array.name/]& _val);
__EXPORT__ void [array.name/]_fromValue(const value::Value* _node,[array.name/]& _val);
[/template]


[template public processVectorType(vector : vectorType)]
// [vector.name/] is a vector of [getVectorDatatypeName(vector)/]
__EXPORT__ value::Value* [vector.name/]_toValue(const [vector.name/]& _val); 
__EXPORT__ void [vector.name/]_fromValue(const value::Value* _node, [vector.name/]& _val);
[/template]


[template public processMapType(map : mapType)]
// [map.name/] is a map with key type [getMapKeyTypeName(map)/] and value type [getMapValueTypeName(map)/]
__EXPORT__ value::Value* [map.name/]_toValue(const [map.name/]& _val);
__EXPORT__ void [map.name/]_fromValue(const value::Value* _node, [map.name/]& _val);
[/template]


[template public processStructType(struct : structType)]
// [struct.name/] is a structure
__EXPORT__ value::Value* [struct.name/]_toValue(const [struct.name/]& _val) ;
__EXPORT__ void [struct.name/]_fromValue(const value::Value* _node, [struct.name/]& _val);
[/template]


[template public processDefineType(define : defineType)]
// [define.name/] is a [getDefineTypeName(define)/]
// Not processed
[/template]
