[comment encoding = UTF-8 /]
[module xmlTypeImpls('http://www.xtext.org/AthenaDSL')/]

[import org::eclipse::robotml::generators::xtext::athena::simu::main::jqueries /]

[template public xmlTypeImpls(project : Project)]
	
[file ('TypeDefs_XML.cc', false, 'UTF-8')] 
// 
// Includes ----------------------------------------------------------------------
// 

#include <sstream>
#include <iomanip>
#include <boost/lexical_cast.hpp>
#include <iostream>

#include "tests.h"
#include "TypeDefs.h"
#include "TypeDefs_XML.h"

using namespace std;

//  
// Data type implementations ----------------------------------------------------------
//

	[for (type : DataType | project.types)]
// -------------------------------------------------------- [type.name/]
 
		[if (isBasicType(type))]
[processBasicType(type.oclAsType(basicType))/]
		[elseif (isArrayType(type))]
[processArrayType(type.oclAsType(arrayType))/]
		[elseif (isVectorType(type))] 
[processVectorType(type.oclAsType(vectorType))/]
		[elseif (isMapType(type))]
[processMapType(type.oclAsType(mapType))/]
		[elseif (isStructType(type))]
[processStructType(type.oclAsType(structType))/]
		[elseif (isDefineType(type))]
[processDefineType(type.oclAsType(defineType))/]
		[elseif (isUnionType(type))]
[processUnionType(type.oclAsType(unionType))/]
		[else]
///
/// ERROR [type.name/] is unrecognized by the generator - [type.eClass()/]
///
		[/if]
		
	[/for]

[/file]
	
[/template]


[template public processBasicType(type : basicType)]
	[let cpp : languageDecl = getCPPLanguageDecl(type) ]
// basic type [type.name/]	
XmlNode* [type.name/]_toXML(const [type.name/]& _val) {
	XmlNode* xn = new XmlNode("[type.name/]");
	ostringstream oss;
	oss << setprecision(16) << _val ;
	xn->setValue(oss.str());
	return xn;
}
[type.name/] [type.name/]_fromXML(XmlNode* _node, const [type.name/]& _initialValue) {
	[type.name/] _[type.name/];
	if (_node != NULL) {
		_[type.name/]=([type.name/])boost::lexical_cast<[getCPPLexicalCast(type)/]>(_node->get("[type.name/]")->get());
		return _[type.name/];
	}
	//cout << "_[type.name/]: no xml found, init value used !" << endl;
	return _initialValue;
}
	[/let]
[/template]


[template public processArrayType(array : arrayType)]
// [array.name/] is an array of [getArrayDatatypeName(array)/]
[let type : DataType = getBaseType(array.typename)]
XmlNode* [array.name/]_toXML(const [array.name/]& _val) {
	XmlNode* xn = new XmlNode("[type.name/]");
	[if (isAOneDimensionArray(array))]
	for(unsigned int _i=0; _i<[getArraySizeOperator(array)/]; _i++) {
		[if (isStructType(type)) ]
		xn->put("val",_i)->add(*[type.name/]_toXML((*_val)['['/]_i[']'/])) ;
		[else]
		xn->put("val",_i)->add(*[type.name/]_toXML([if (isDynamicArray(array))](*_val)[else]_val[/if]['['/]_i[']'/])) ;
		[/if]
	}
	[else]
	// Conversion to XML: only one dimension arrays are accepted !
	[/if]
	return xn;
}
void [array.name/]_fromXML(XmlNode* _node,[array.name/]& _val) {
	[if (isAOneDimensionArray(array))]
	for(unsigned int _i=0; _i<[getArraySizeOperator(array)/]; _i++) {
		[if (isStructType(type)) ]
		(*_val)['['/]_i[']'/].fromXML(_node->get("[type.name/].val",_i)) ; 
		[else]
		[if (isDynamicArray(array))](*_val)[else]_val[/if]['['/]_i[']'/] = [type.name/]_fromXML(_node->get("[type.name/].val",_i)) ;
		[/if]
	}
	[else]
	// Conversion from XML: only one dimension arrays are accepted !
	[/if]

}
[/let]
[/template]


[template public processVectorType(vector : vectorType)]
// [vector.name/] is a vector of [getVectorDatatypeName(vector)/]
XmlNode* [vector.name/]_toXML(const [vector.name/]& _val) {
	[let typename : String = getVectorDatatypeName(vector)]
	XmlNode* _xn = new XmlNode("[vector.name/]");
	[vector.name/]::const_iterator it = _val.begin();
	for (unsigned int _i=0;it != _val.end(); it++) {
		[if (isArrayType(vector.typename))]
			[let array : arrayType = vector.typename.oclAsType(arrayType)]
			[if (isDynamicArray(array))]
		_xn->put("val",_i)->add(*[typename/]_toXML((*_val)['['/]_i[']'/])) ;
			[else]
		_xn->put("val",_i)->add(*[typename/]_toXML(@_val['['/]_i[']'/])) ;
			[/if]
			[/let]
		[else] [if (isStructType(vector.typename))]	
		_xn->put("val",_i)->add(*([typename/]_toXML(*it))) ;
			[else]
		_xn->put("val",_i)->add(*[typename/]_toXML(_val['['/]_i[']'/])) ;
			[/if]
		[/if]
		_i++;
	}
	return _xn;
	[/let]
}
[vector.name/] [vector.name/]_fromXML(XmlNode* _node) {
	[let typename : String = getVectorDatatypeName(vector)]
	[vector.name/] _[vector.name/];
	XmlNode* _xn = _node->get("[vector.name/]");
	for (unsigned int _i=0; _i<_xn->size(); _i++) {
		XmlNode* _n = _xn->get("val", _i);
		[typename/] _val;
		[if (isStructType(vector.typename))]
		[typename/]_fromXML(_n, _val) ;
		[else]
		_val = [typename/]_fromXML(_n) ;
  		[/if]	
		_[vector.name/].push_back(_val);
	}
	return _[vector.name/];
	[/let]
}
[/template]


[template public processMapType(map : mapType)]
// [map.name/] is a map with key type [getMapKeyTypeName(map)/] and value type [getMapValueTypeName(map)/]
	[let keytypename : String = getMapKeyTypeName(map)]
	[let datatypename : String = getMapValueTypeName(map)]
XmlNode* [map.name/]_toXML(const [map.name/]& _val) {
	XmlNode* _xn = new XmlNode("[map.name/]");
	[map.name/]::const_iterator it = _val.begin();
	for (unsigned int _i=0;it != _val.end(); it++) {
		_xn->put("val",_i)->add("_key", lexical_cast<string>((*it).first));
		[if (isArrayType(map.valtype))]
			[let array : arrayType = map.valtype.oclAsType(arrayType)]
			[if (isDynamicArray(array))]
		_xn->put("val",_i)->add(*[datatypename/]_toXML(*((*it).second))) ;
			[else]
		_xn->put("val",_i)->add(*[datatypename/]_toXML((*it).second));
			[/if]
			[/let]
		[else] 	
		_xn->put("val",_i)->add(*([datatypename/]_toXML((*it).second))) ;
		[/if]
		_i++;
	}
	return _xn;

}
[map.name/] [map.name/]_fromXML(XmlNode* _node) {
	[map.name/] _[map.name/];
	XmlNode* _xn = _node->get("[map.name/]");
	for (unsigned int _i=0; _i<_xn->size(); _i++) {
		XmlNode* _n = _xn->get("val", _i);
		[datatypename/] _val;
		[keytypename/] _key;
		[if (isBasicType(map.keytype))]
			[let bt : basicType = map.keytype.oclAsType(basicType)]
			[let cast : String = getCPPLexicalCast(bt)]
		_key = ([keytypename/])boost::lexical_cast<[cast/]>(_n->get("_key")->get()) ;
			[/let]
			[/let]
		[else] 
		_key = ([keytypename/])(_n->get("_key")->get()) ;
		[/if]
		[if (isStructType(map.valtype))]
		[datatypename/]_fromXML(_n, _val) ;
		[else]
		_val = [datatypename/]_fromXML(_n) ;
  		[/if]	
		_[map.name/]['['/]_key[']'/]=_val;
	}
	return _[map.name/];
}
	[/let]
	[/let]
[/template]


[template public processStructType(struct : structType)]
// [struct.name/] is a structure
XmlNode* [struct.name/]_toXML(const [struct.name/]& _val) {
	XmlNode* xn = new XmlNode("@type.name@");
	[for (param : structElement | struct.parameters)]
	[if (isUnionType(param.typename))]
	[else]
	xn->add("[param.name/]")->add(*[param.typename.name/]_toXML(_val.[param.name/]));
	[/if]
	[/for]
	return xn;
}
void [struct.name/]_fromXML(XmlNode* _node, [struct.name/]& _val) {
	[for (param : structElement | struct.parameters)]
		[let ptype : DataType = getBaseType(param.typename)]
			[if (isBasicType(ptype))]
				[if (param.hasInitValue)]
	_val.[param.name/] = [ptype.name/]_fromXML(_node->get("[struct.name/].[param.name/]"), [param.initValue/]);
				[else]
	_val.[param.name/] = [ptype.name/]_fromXML(_node->get("[struct.name/].[param.name/]"));
				[/if]
			[elseif (isArrayType(ptype) or isStructType(ptype))]
	[ptype.name/]_fromXML(_node->get("[struct.name/].[param.name/]"), _val.[param.name/]);
			[elseif (isUnionType(ptype))]
			
			[else]
	_val.[param.name/] = [ptype.name/]_fromXML(_node->get("[struct.name/].[param.name/]"));
			[/if]
		[/let]
	[/for]
}
[/template]


[template public processDefineType(define : defineType)]
// [define.name/] is a [getDefineTypeName(define)/]
[let type : DataType = getBaseType(define)]
XmlNode* [define.name/]_toXML(const [define.name/]& _val) {
	return [type.name/]_toXML(_val);
}
[if (isStructType(type) or isArrayType(type))]
void [define.name/]_fromXML(XmlNode* _node, [define.name/]& _val) {
	[type.name/]_fromXML(_node, _val);
[else]
[define.name/] [define.name/]_fromXML(XmlNode* _node) {
	return [type.name/]_fromXML(_node);
[/if]
}
[/let]
[/template]


[template public processUnionType(union : unionType)]
// [union.name/] is a union
	// Conversion from/to XML: union not processed !
[/template]




