[comment encoding = UTF-8 /]
[module generate_Datatype_file('http://www.eclipse.org/uml2/3.0.0/UML')]
[import org::eclipse::robotml::generators::acceleo::mmqueries::DataTypeQueries /]
[import org::eclipse::robotml::generators::acceleo::mmqueries::GeneralQueries /]
[import org::eclipse::robotml::generators::acceleo::mmqueries::ArchitectureQueries /]
[import org::eclipse::acceleo::module::OrocosGenerator::mmqueries::OrocosQueries/]

[template public generate_Datatype_file(c : Class, m: Model)]
[comment] [for (elt : Element | getDataTypesInClass(c))] [/comment]
[for (elt : Element | getElementsDataType(m))]
[let type: Type = elt] [comment] (isRobotMLDataType(m, type.name)  = false) and [/comment]
[if(isPrimitiveType(type) = false)] [comment] introduire test sur le plan de d√©ploiement [/comment]
[if (isExistingType(type) = false)]
[file ( 'src/DataTypes/'+type.name.substitute(' ', '_')+'.hpp', false, 'UTF-8')]
#ifndef _[type.name.toUpper()/]_H_
#define _[type.name.toUpper()/]_H_
[addType(type)/]
[for (elt : Element | getDataTypesInElement(type))]
[let type: Type = elt] 
[if(isRobotMLDataType(m, type.name))]
[let ne : NamedElement = type.owner]
#include <[ne.name.replace('_datatypes', '_msgs')/]/[type.name/].h>
[/let]
[else]
	[if(not isPrimitiveType(type))]
#include "[((type.qualifiedName).replaceAll(' ', '_')).replaceAll('::', '/')/].h"	
	[/if]
[/if]
[/let]
[/for]
[comment get owner component and modify namespaces hierarchy/]
namespace [(type.qualifiedName.substitute('::'+type.name,'')).substitute(' ','_')/]{
	[if(isEnumeration(type))]
	enum [type.name/]{
	[for (enumeration : EnumerationLiteral |getEnumeration(type))]
	[enumeration.name/];
	[/for]
    }
	[else]
	struct [type.name/]{
	[for (property : Property |getProperties(type))]
    [let t :Type = property.type]

 [comment] conversion to ROS types done using getNameType(t) but missing conversion 
  to c++ types using convertType(type.name) => needs the use of the deploiement plan [/comment]
    [if(isPrimitiveType(t))]
	[if(t.name.equalsIgnoreCase('boolean'))]
	[property.visibility/] bool [property.name/];
	[else]
		[property.visibility/] [t.name/] [property.name/];
	[/if]
	
	[else]
		[property.visibility/] [t.name/] [property.name/];
	[/if]
	[comment]
	[if(isRobotMLDataType(m, t.name))]
	[property.visibility/] [t.owner/]::[t.name/] [property.name/];
	[/if]
	[/comment]
	[/let]	
	[/for]	
  }
 	[for (op : Operation |getOperations(type))]
		[comment] [operation.visibility/]	[operation.type/] [operation.name/] ([getOperationSignature(operation)/]); [/comment]
		[if(op.isStatic)]
	    [op.visibility/] static [convertType(op.type, m)/] [op.name/] (
		[/if]
		[if(op.isAbstract and not op.isStatic)]
		[op.visibility/] virtual [convertType(op.type, m)/] [op.name/] (
		[/if]
		[if(getOperationInputParameters(op) <> null)]
		[for (input: Element | getOperationInputParameters(op))]
			[let p : Parameter = input]
			[comment] [getOperationParameterType(op, p)/] [/comment]
			[p.type.name/] [p.name/] ,
			[/let]
		[/for]
		[/if]
		[if(getOperationOutputParameters (op) <> null)]
		[for (output: Element | getOperationOutputParameters(op))]
			[let p : Parameter = output]
			[comment] [getOperationParameterType(op, p)/] [/comment]
			[p.type.name/] &[p.name/],
			[/let]
		[/for]
		[/if]
        )
    [/for]
[/if]
}
#endif // _[type.name.toUpper()/]_H_
[/file]
[/if]
[/if]

[/let]
[/for]
[/template]
