[comment encoding = UTF-8 /]
[module generate_orocos_component_hpp('http://www.eclipse.org/uml2/3.0.0/UML')]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::ArchitectureQueries /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::DataTypeQueries /]
[import org::eclipse::papyrus::robotml::generators::orocos::mmqueries::OrocosQueries/]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_orocos_interface_hpp /]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_FSM/]
[import org::eclipse::papyrus::robotml::generators::orocos::main::generate_Datatype_file /]
[import org::eclipse::papyrus::robotml::generators::common::mmqueries::GeneralQueries /]

[template public generateOrocosComponentHpp(c : Class, root_model : Model)]
[file ( 'src/'+c.name+'/'+c.name+'.hpp', false, 'UTF-8')]
#include <rtt/TaskContext.hpp>
#include <ocl/Component.hpp>
#include <rtt/Port.hpp>
#include <iostream>
#include <numeric>
#include <string>
[comment To import libraries, we check if the current component is connected to a hardware component. In that case, a ROS library is imported. Else, the user data type library 
is imported/]

//Libraries related to source components
[for(p : Port | getInputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
#include "../DataTypes/[t.name/].hpp"
	[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
	[/if]
[elseif (isPrimitiveType(t) and ((isActuator(p1.class)=true) or (isSensor(p1.class) = true)))]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[/if]
[/for]
[/if]

[/let]
[/for]

//Libraries related to target components
[for(p : Port | getOutputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
#include "../DataTypes/[t.name/].hpp"
	[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
	[/if]
[elseif (isPrimitiveType(t) and ((isActuator(p1.class)=true) or (isSensor(p1.class) = true)))]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[else]
#include<[t._package.name.replace('_datatypes', '_msgs')+'/'+t.name+'.h'/]>
[/if]
[/for]
[/if]

[/let]
[/for]

[comment importing interfaces/]
//interface import
[for (elt : Element | getDataTypesInElement(c))]
[let type: Type = elt]
		[if (isInterface(type))]
		#include "../[type.name+'/Task'+type.name/].hpp"
		[/if]
[/let]
[/for]

#include <stdlib.h>
#include <math.h>

using namespace std;
using namespace RTT;

[generate_Datatype_file(c, root_model)/]
[let nspace : String = c.qualifiedName.substitute('::'+c.name,'')]
[let nameSpace : Sequence(String) = nspace.tokenize('::')]
[for(s : String | nameSpace)]
namespace [s/]{
[/for]
[/let]
[/let]
class [c.name/]: public RTT::TaskContext
{   [comment ports and services declaration/]
[let elt : Element = c.oclAsType(Element)]
			[for (sp : Port | getServicePort())]				
				[let interface : Interface = sp.type]
				[generateOrocosInterfaceHpp(interface, root_model)/]
					[for (op : Operation | interface.getAllOperations())]
						[if (isARequiredPort(sp))]
[let t :Type = op.type]
	[if (t = null)]
		RTT::OperationCaller <void(
		[if(getOperationInputParameters(op) <> null)]	
			[for (input: Element | getOperationInputParameters(op))]
			[let p : Parameter = input]
			[let paramType : Type = p.type]
			[if(isPrimitiveType(paramType))]
				[if(paramType.name.equalsIgnoreCase('boolean') or paramType.name.equalsIgnoreCase('Bool'))]
				bool [p.name/],
				[else]
				[paramType.name/] [p.name/],
				[/if]
			[else]
				[paramType.name/] [p.name/],
			[/if]
			[comment in case of ros datatypes, uncomment]
			[if(isRobotMLDataType(m, paramType.name))]
				[let ne : NamedElement = paramType.owner]
				[ne.name.replace('_datatypes', '_msgs')/]::[paramType.name/] [p.name/], 
				[/let]
			[else]
				[paramType.name/] [p.name/],
			[/comment] 
			[/let]
			[/let]
			[/for]
		[else]
			void
		[/if]
		)>[interface.name/]_[op.name/];
	[else]
		RTT::OperationCaller <[t.name/](
		[if(getOperationInputParameters(op) <> null)]
		[for (input: Element | getOperationInputParameters(op))]
			[let p : Parameter = input]
			[let paramType : Type = p.type]
			[if(isPrimitiveType(paramType))]
				[if(paramType.name.equalsIgnoreCase('boolean') or paramType.name.equalsIgnoreCase('Bool'))]
				bool [p.name/],
				[else]
				[paramType.name/] [p.name/],
				[/if]
			[else]
				[paramType.name/] [p.name/],
			[/if]
			[comment in case of ros datatypes, uncomment]
			[if(isRobotMLDataType(m, paramType.name))]
				[let ne : NamedElement = paramType.owner]
				[ne.name.replace('_datatypes', '_msgs')/]::[paramType.name/] [p.name/], 
				[/let]
			[else]
				[paramType.name/] [p.name/],
			[/comment] 
		    [/let]
			[/let]
		    [/for]
		[else]
			void
		[/if]
		)>[interface.name/]_[op.name/];
	[/if]
[/let]				
[/if]
[/for]
[/let]				
			[/for]
		[/let]




//input ports
[for(p : Port | getInputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
[p.visibility/]: InputPort<[t.qualifiedName/]> [p.name/];
	[else]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(p1.class)=true) or (isSensor(p1.class) = true))]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[else]
[p.visibility/]: InputPort<[t.name/]> [p.name/];
[/if]
[else]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[/if]
[/for]
[/if]

[/let]
[/for]

//Output ports
[for(p : Port | getOutputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(p1 : Port | getConnectedPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(p1.class)=false) and (isSensor(p1.class) = false))]
[p.visibility/]: OutputPort<[t.qualifiedName/]> [p.name/];
	[else]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(p1.class)=true) or (isSensor(p1.class) = true))]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[else]
[p.visibility/]: OutputPort<[t.name/]> [p.name/];
[/if]
[else]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[/if]
[/for]
[/if]

[/let]
[/for]
[comment]
[for(p : Port | getInputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(s : Connector | getConnectionsFromPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(getSourceComponentForConnector(s).class)=false) and (isSensor(getDestComponentForConnector(s).class) = false))]
	[p.visibility/]: InputPort<[t.qualifiedName/]> [p.name/];
	[else]
	[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(getSourceComponentForConnector(s).class)=true) or (isSensor(getSourceComponentForConnector(s).class) = true))]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[else]
[p.visibility/]: InputPort<[t.name/]> [p.name/];
[/if]
[else]
[p.visibility/]: InputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[/if]
[/for]
[/if]
[/let]
[/for]

[for(p : Port | getOutputPortsForElement(c))]
[let t: Type = p.type]
[if(not isInterface(t))]
[for(s : Connector | getConnectionsFromPort(p))]
[if (alreadyDefinedDataType(t.qualifiedName, root_model))] 
	[if((isActuator(getDestComponentForConnector(s).class)=false) and (isSensor(getDestComponentForConnector(s).class) = false))]
	[p.visibility/]: OutputPort<[t.qualifiedName/]> [p.name/];
	[elseif((isActuator(getDestComponentForConnector(s).class)=true) or (isSensor(getDestComponentForConnector(s).class) = true))]
	[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
	[/if]
[elseif (isPrimitiveType(t))]
[if((isActuator(getDestComponentForConnector(s).class)=true) or (isSensor(getDestComponentForConnector(s).class) = true))]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[else]
[p.visibility/]: OutputPort<[t.name/]> [p.name/];
[/if]
[else]
[p.visibility/]: OutputPort<[t._package.name.replace('_datatypes', '_msgs')+'::'+t.name/]> [p.name/];
[/if]
[/for]
[/if]
[/let]
[/for]
[/comment]

[comment old version]

	[let elt : Element = c.oclAsType(Element)]
 		[for (port : Port | getInputPortsForElement(elt))] 
			[if (isRobotMLDataType(root_model, port.type.name))]
			[let ne : NamedElement = port.type.owner]
			[port.visibility/]: InputPort<[ne.name.replace('_datatypes', '_msgs')/]::[port.type.name/]> [port.name/];
			[/let]
			[else]
			[port.visibility/]: InputPort<[port.type.qualifiedName/]> [port.name/];
			[/if]
		[/for]
  		[for (port : Port | getOutputPortsForElement(elt))]
			[if (isRobotMLDataType(root_model, port.type.name))]
			[let ne : NamedElement = port.type.owner]
			[port.visibility/]: OutputPort<[ne.name.replace('_datatypes', '_msgs')/]::[port.type.name/]> [port.name/];
			[/let]
			[else]
			[port.visibility/]: OutputPort<[port.type.name/]> [port.name/];
			[/if]		
		[/for]
	[/let]
[/comment]


	[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
             public: Task[interface.name/]* task[interface.name/];
				[/if]
		[/let]
[/for]
	
	[comment constructor/]// Constructor
	[c.visibility/]: [c.name/] (const std::string& name)
		: [comment]
		[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
             Task[interface.name/]((std::string&)"[interface.name/]"),
				[/if]
		[/let]
		[/for] 
		[/comment]

		TaskContext(name) 							
		[let elt : Element = c.oclAsType(Element)]
		[for (port : Port | getAllPorts(elt))]
			, [port.name/]("[port.name/]")	
		[/for]
		[/let]
		[for (sp : Port | getServicePort())]				
			[let interface : Interface = sp.type]
				[for (op : Operation | interface.getAllOperations())]
					[if (isARequiredPort(sp))]
			, [interface.name/]_[op.name/] ("[interface.name/]_[op.name/]")
					[/if]
       			[/for]
			[/let]				
		[/for]	
  		{ 	
		[comment adding ports to the constructor/]
		[let elt : Element = c.oclAsType(Element)]
			[for (port : Port | getAllPorts(elt))]
		this->ports()->addPort([port.name/]);	
			[/for]
		[/let]

		[comment Subcomponents must be handled differently in Orocos/]
		[comment]
		[for ( property1: Property | getAllSubComponentsInClass(c))]
			[if (not isActuator(getclass(property1))) and (not isSensor(getclass(property1)))]
		this->addProperty("[property1.type.name.toLower()/]", [property1.type.name.toLower()/]).doc("Description :  [property1.type.name.toUpperFirst()/]") ;	
			[/if]
		[/for]
		[/comment]
		[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
        task[interface.name/] = new Task[interface.name/](this);
				[/if]
		[/let]
		[/for]
		[comment adding Properties to the constructor /]	
		[let elt : Element = c.oclAsType(Element)]
			[for (property : Property | getProperties(c,elt))]
		this->addProperty("[property.name/]", [property.name/]);
			[/for]
		[/let]

[comment adding operations to the constructor /]	
	[for (op : Operation | c.getAllOperations())]
		this->addOperation("[interface.name/]_[op.name/]", &[c.name/]::[op.name/], this, RTT::ClientThread)[getOperationSignatureName(op)/]
			.doc("Description : [op.type.name.toUpper()/]");
		[/for]

        [let elt : Element = c.oclAsType(Element)]
			[for (sp : Port | getServicePort())]				
				[let interface : Interface = sp.type]
					[for (op : Operation | interface.getAllOperations())]
						[if (isARequiredPort(sp))]
		this->requires("Task[interface.name/]")
			->addOperationCaller([interface.name/]_[op.name/]);
						[/if]
       				[/for]
				[/let]				
			[/for]
		[/let]
	}
	[comment destructor/]// Destructor
    ~[c.name/]() {
		[for (sp : Port | getServicePort())]				
		[let interface : Interface = sp.type]
				[if (isAProvidedPort(sp))]
        delete task[interface.name/];
				[/if]
		[/let]
		[/for]
	}
	[comment components methods/]
	/**
	 * This function is for the configuration code.
     * Return false to abort configuration.
     */
	bool configureHook() {
			[for (sp : Port | getServicePort())]				
			[let interface : Interface = sp.type]
				[if (isARequiredPort(sp))]

[comment]
					[let p : Port = getOppositePort(sp)]
		if (!(requires("[interface.name/]")->connectTo(getPeer("[p.class.name/]")->provides("[interface.name/]")))){
			log(Info) << "connection problem to service" << endlog();
		}
					[/let]
[/comment]

				[/if]
			[/let]				
		[/for]
		// ...
		return true;
	}

	/**
	 * This function is for the application's start up code.
	 * Return false to abort start up.
	 */
	bool startHook() {
		// ...
		return true;
	}

	/**
	 * This function is called by the Execution Engine.
	 */
	void updateHook() {
		// algorithm goes here.
	}

	/**
	 * This function is called when the task is stopped.
 	 */
	void stopHook() {
		// stop code after last updateHook()
	}

	/**
	 * This function is called when the task is being deconfigured.
	 */
	void cleanupHook() {
		// Your configuration cleanup code
	}	
};

[let nspace : String = c.qualifiedName.substitute('::'+c.name,'')]
[let nameSpace : Sequence(String) = nspace.tokenize('::')]
[for(s : String | nameSpace)]
}
[/for]
[/let]
[/let]
[/file]

[/template]