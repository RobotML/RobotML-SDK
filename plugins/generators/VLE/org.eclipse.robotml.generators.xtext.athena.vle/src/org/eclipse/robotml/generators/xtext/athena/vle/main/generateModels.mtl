[comment encoding = UTF-8 /]
[module generateModels('http://www.xtext.org/AthenaDSL')]

[import org::eclipse::robotml::generators::xtext::athena::vle::main::DSLQueries /]

[template public generateModels(project : Project)]
[for (proto : prototypeDeclaration | project.prototypes)]
[let fname : String = 'generated/src/'.concat(getPrototypeFileName(proto,'.cpp'))]
[file (fname, false, 'UTF-8')]
[generateModelImplementation(project, proto)/]
[/file]
[/let]
[/for]
[/template]

[template public generateModelImplementation(project: Project, proto : prototypeDeclaration)]
#include <vle/value.hpp>
#include <vle/devs.hpp>
#include <TypeDefs.h>
#include <TypeDefs_Values.h>

namespace vd = vle::devs;
namespace vv = vle::value;

namespace generated {

class [proto.name/] : public vd::Dynamics
{
private:

	// references ----------------------------------------------------------------------------------------------
		
	[for (p : prototypeDeclaration | project.prototypes)]
	[if (isAnAncestorOf(proto, p))]
	[for (elt : architectureElement | p.definitions)]
		[if (isReference(elt))]
			[let ref : referenceDeclaration = elt.oclAsType(referenceDeclaration)]
	[ref.typeName.name/] [getReferenceName(ref)/];
			[/let]
		[/if]
	[/for]
	[/if]
	[/for]

	// parameters ----------------------------------------------------------------------------------------------

	[for (p : prototypeDeclaration | project.prototypes)]
	[if (isAnAncestorOf(proto, p))]
	[for (elt : architectureElement | p.definitions)]
		[if (isParameter(elt))]
			[let param : parameterDeclaration = elt.oclAsType(parameterDeclaration)]
	[param.typeName.name/] [param.name/];		
			[/let]
		[/if]
	[/for]
	[/if]
	[/for]

public:

	/**
	 *
	 */
    [proto.name/](const vd::DynamicsInit& init, const vd::InitEventList& events)
        : vd::Dynamics(init, events)
    {
    }

	/**
	 *
	 */
    virtual ~[proto.name/]()
    {
    }

	/**
	 *
	 */
    virtual vd::Time init(const vd::Time& /*time*/)
    {
        return vd::Time(1);
    }

	/**
	 *
	 */
    virtual void output(const vd::Time& /*time*/,
                        vd::ExternalEventList& /*output*/) const
    {
    }

	/**
	 *
	 */
    virtual vd::Time timeAdvance() const
    {
        return vd::Time(1);
    }

	/**
	 *
	 */
    virtual void internalTransition(const vd::Time& /*time*/)
    {
    }

	/**
	 *
	 */
    virtual void externalTransition(const vd::ExternalEventList& eventList,
                                    const vd::Time& /*time*/)
    {
        vd::ExternalEventList::const_iterator it = eventList.begin();
        for (;it != eventList.end(); it++)
        {
			const vd::ExternalEvent& event = *(*it);
	[for (p : prototypeDeclaration | project.prototypes)]
	[if (isAnAncestorOf(proto, p))]
	[for (elt : architectureElement | p.definitions)]
		[if (isReference(elt))]
			[let ref : referenceDeclaration = elt.oclAsType(referenceDeclaration)]
            // 
            if (event.onPort("[getReferenceName(ref)/]"))
            {
			    const vv::Value& val = event.getAttributeValue("hello");
				[if(isStructType(ref.typeName) or isArrayType(ref.typeName) or isVectorType(ref.typeName) or isMapType(ref.typeName))]
				[ref.typeName.name/]_fromValue(&val, [getReferenceName(ref)/]);
				[else]
				[getReferenceName(ref)/] = [ref.typeName.name/]_fromValue(&val);
				[/if]
            }
			[/let]
		[/if]
	[/for]
	[/if]
	[/for]
		}
    }

	/**
	 *
	 */
    virtual void confluentTransitions(const vd::Time& time,
                                      const vd::ExternalEventList& events)
    {
        internalTransition(time);
        externalTransition(events, time);
    }

	/**
	 *
	 */
    virtual void request(const vd::RequestEvent& /*event*/,
                         const vd::Time& /*time*/,
                         vd::ExternalEventList& /*output*/) const
    {
    }

	/**
	 *
	 */
    virtual vv::Value* observation(const vd::ObservationEvent& /*event*/) const
    {
        return 0;
    }

	/**
	 *
	 */
    virtual void finish()
    {
    }

};
} // namespace generated

DECLARE_DYNAMICS(generated::[proto.name/])
[/template]
