[comment encoding = UTF-8 /]
[module CPPObjectImpl('http://www.xtext.org/AthenaDSL')/]

[import org::eclipse::robotml::generators::xtext::athena::simu::main::jqueries /]

[template public CPPObjectImpl(project : Project)]
	
[for (proto : prototypeDeclaration | project.prototypes)]
[let fname : String = getPrototypeFileName(proto,'.cc')]
[file (fname, false, 'UTF-8')] 
[generateImplementation(project, proto)/]
[/file]
[/let]
[/for]

[/template]

[template private generateImplementation(project : Project, proto : prototypeDeclaration)]
//----------------------------------------------------------------
// Include files
//---------------------------------------------------------------- 
#include "Compatibility.h"
#include "timeCheck.h"
#include "TypeDefs_XML.h"
#include <iostream>
#include "tests.h"
#include "[getPrototypeFileName(proto,'.h')/]"

using namespace std;

extern "C" __IMPORT__ void* getUserFunction(const std::string& name);

namespace generated 
{
	//using namespace generated;
	
	[generateConstructor(proto)/]
	[generateDestructor(proto)/]
	[generateDoInit(project, proto)/]
	[generateDoConnect(project, proto)/]
	[generateDoStep(project, proto)/]
	[generateInteractionsCall(project, proto)/]
	[generateEvents(project, proto)/]
	[generateReferences(project, proto)/] 

} /* namespace generated */
[/template]

[template private generateConstructor(proto : prototypeDeclaration)]	
//******************************
// Constructor
//******************************
[proto.name/]::[proto.name/](XmlNode* config)
{
	if(config != NULL)
	{
	}
} 
[/template]

[template private generateDestructor(proto : prototypeDeclaration)]	
//******************************
// Destructor
//******************************
[proto.name/]::~[proto.name/]()
{
	//instances destructions
	delete_children();
} 
[/template]

[template private generateDoInit(project : Project, proto : prototypeDeclaration)]
//******************************
// doInit
//******************************
void [proto.name/]::doInit()
{
	[generateParameterInit(project, proto)/]
	[generateParameterInitXML(project, proto)/]
	[generateFonctorsInit(project, proto)/]
	[generateStateSetsInit(project, proto)/]
}
[/template]

[template private generateDoConnect(project : Project, current_proto : prototypeDeclaration)]
//******************************
// doConnect
//******************************
void [current_proto.name/]::doConnect()
{
[let refs : Sequence(referenceDeclaration) = getReferences(project, current_proto)]
[for(ref : referenceDeclaration | refs)]
	// reference [getReferenceName(ref)/], up? =  [ref.upway/], path = [getStringFromQualifiedName(ref.name)/]
	[getReferenceName(ref)/] = NULL;
[if (ref.upway)] 
	[getReferenceName(ref)/] = lookUpForParameter<[ref.typeName.name/]>("[getStringFromQualifiedName(ref.name)/]"); 
[else] 
	[getReferenceName(ref)/] = lookDownForParameter<[ref.typeName.name/]>("[getStringFromQualifiedName(ref.name)/]");
[/if]
	if ([getReferenceName(ref)/] == 0)
		cout << "In an instance of [current_proto.name/], connection to parameter @[ref.name/]@ failed !!" << endl;
	__REQUIRE([getReferenceName(ref)/] != 0);
[/for]
[/let]
}
[/template]

[template private generateDoStep(project : Project, proto : prototypeDeclaration)]
//******************************
// doStep
//******************************
void [proto.name/]::doStep(const long& icycle)
{
	[generateTransitionStep(project, proto)/]
	[generateInteractionsStep(project, proto)/]
}
[/template]

[template private generateParameterInit(project : Project, current_proto : prototypeDeclaration)]
[let params : Sequence(parameterDeclaration) = getParameters(project, current_proto)]
[if(params->isEmpty() = false)]
//Initialize parameter
[for(param : parameterDeclaration | params)]
// [param.name/], [param.typeName.name/]
add_parameter<[param.typeName.name/]>("[param.name/]", &[param.name/]);
init_[param.typeName.name/]([param.name/]['['/]0[']'/]);
init_[param.typeName.name/]([param.name/]['['/]1[']'/]);
[param.name/].set_name("[current_proto.name/].[param.name/]");
[if(param.hasNbW)]
[param.name/].set_nb_writers([getParameterNbWriters(param)/]);
[elseif(param.hasInfiniteWriter)]
[param.name/].set_nb_writers(2147483647);
[else]
[param.name/].set_nb_writers(1);
[/if]	
[if (hasInitValue(param.typeName))]
[param.name/].init((long)0,[getInitValue(param.typeName.oclAsType(basicType))/]) ;
[/if]
[/for]
[/if]
[/let]
[/template]

[template private generateParameterInitXML(project : Project, current_proto : prototypeDeclaration)]
[let params : Sequence(parameterDeclaration) = getParameters(project, current_proto)]
[if(params->isEmpty() = false)]
//Initialize parameter from XML
[for(param : parameterDeclaration | params)]
[if (isArrayType(param.typeName))]
[if isDynamicArray(param.typeName.oclAsType(arrayType))]
// Allocate [param.name/], [param.typeName.name/]
try 
{
	[param.name/]['['/]0[']'/]=[param.typeName.name/]_allocate([getArrayAllocationCall(param.name, param.typeName.oclAsType(arrayType))/]) ;
	[param.name/]['['/]1[']'/]=[param.typeName.name/]_allocate([getArrayAllocationCall(param.name, param.typeName.oclAsType(arrayType))/]) ;
}
catch (...)
{
	__FAIL("error creating [param.name/] in [current_proto.name/]");
}

[/if]
[elseif (isStructType(param.typeName))]
[if (hasDynamicArrayElements(param.typeName.oclAsType(structType)))]
// Allocate [param.name/], [param.typeName.name/]
try 
{
	[param.name/]['['/]0[']'/].allocate([getDynamicAllocationForStruct(param.name, param.typeName.oclAsType(structType))/]);
	[param.name/]['['/]1[']'/].allocate([getDynamicAllocationForStruct(param.name, param.typeName.oclAsType(structType))/]);
}
catch (...)
{
	__FAIL("error creating [param.name/] in [current_proto.name/]");
}

[/if]
[/if]
[if (param.hasConfig or param.hasConfigWithDefaultValue)]
// from XML [param.name/], [param.typeName.name/]
try 
{
[if (isArrayType(param.typeName))]
	[param.typeName.name/]_fromXML(get_config()->get("[param.name/]"), [param.name/]['['/]0[']'/]);
	[param.typeName.name/]_fromXML(get_config()->get("[param.name/]"), [param.name/]['['/]1[']'/]);
[elseif (isStructType(param.typeName))]
	[param.typeName.name/]_fromXML(get_config()->get("[param.name/]"), [param.name/]['['/]0[']'/]);
	[param.typeName.name/]_fromXML(get_config()->get("[param.name/]"), [param.name/]['['/]1[']'/]);
[else]
	[param.name/]['['/]0[']'/] =[param.typeName.name/]_fromXML(get_config()->get("[param.name/]"));
	[param.name/]['['/]1[']'/] =[param.typeName.name/]_fromXML(get_config()->get("[param.name/]"));
[/if]
}
catch (...)
{
	__FAIL("error reading [param.name/] from XML in [current_proto.name/]");
}
[/if]
[/for]
[/if]
[/let]
[/template]

[template private generateFonctorsInit(project : Project, current_proto : prototypeDeclaration)]
[let interactions : Sequence(interactionDeclaration) = getInteractions(project, current_proto)]
[if(interactions->isEmpty() = false)]
// Functors initialisation
try
{
[for(interaction : interactionDeclaration | interactions)]
[for (call : interactionCall | interaction.icalls)]
	_[call.fctName.name/] = (void (*)([getFunctorDeclaration(call.fctName)/])) getUserFunction("[call.fctName.name/]");
[/for]
[/for]
}
catch(...)
{
	cout << "Problem loading functors for instance [current_proto.name/]" << endl;
	exit(-1);
}
[/if]
[/let]
[/template]


[template private generateStateSetsInit(project : Project, current_proto : prototypeDeclaration)]
[let statesets : Sequence(statesetDeclaration) = getStateSets(project, current_proto)]
[if(statesets->isEmpty() = false)]
//Statesets initialisation
[for(stateset : statesetDeclaration | statesets)]
[stateset.name/].init((long)0, [stateset._init.name/]);
[/for]
[/if]
[/let]
[/template]

[template private generateTransitionStep(project : Project, current_proto : prototypeDeclaration)]
[let statesets : Sequence(statesetDeclaration) = getStateSets(project, current_proto)]
[if(statesets->isEmpty() = false)]
//transition for each stateset
[for(stateset : statesetDeclaration | statesets)]
[for (trans : transitionDeclaration | stateset.transitions)]
if ( ([stateset.name/].getRead(icycle) == [trans.from/] ) && event_[trans.evt/](icycle) )
{
	[stateset.name/].write(icycle,[trans.to/]);
[if (trans.raise)]
	[trans.sig/].raise(icycle);
[/if]
}
[/for]
[/for]
[/if]
[/let]
[/template]

[template private generateInteractionsStep(project : Project, current_proto : prototypeDeclaration)]
[let interactions : Sequence(interactionDeclaration) = getInteractions(project, current_proto)]
[if(interactions->isEmpty() = false)]
[for(interaction : interactionDeclaration | interactions)]
[for (call : interactionCall | interaction.icalls)]
interaction_[call.fctName.name/](icycle);
[/for]
[/for]
[/if]
[/let]
[/template]


[template private generateInteractionsCall(project : Project, current_proto : prototypeDeclaration)]
[let interactions : Sequence(interactionDeclaration) = getInteractions(project, current_proto)]
[if(interactions->isEmpty() = false)]
[for(interaction : interactionDeclaration | interactions)]
[for (call : interactionCall | interaction.icalls)]
[generateInteraction(project, current_proto, interaction, call)/]
[/for]
[/for]
[/if]
[/let]
[/template]

[template private generateInteraction(project : Project, current_proto : prototypeDeclaration, interaction : interactionDeclaration, call : interactionCall)]
// Interaction [call.fctName.name/]
void [current_proto.name/]::interaction_[call.fctName.name/](const long& icycle) 
{
	// Time measurement
	AthenaV3::getStaticTimeMap().startRecordSample("[current_proto.name/]::[call.fctName.name/]");
[if (interaction.wwhen)]
	if ([interaction.stateset/].getRead(icycle) == [interaction.wstate/])
[/if]
[if (interaction.iif)]
	if (event_[interaction.event/](icycle))
[/if]
	{
		// Access to arguments
		[getArgumentDeclaration(project, current_proto, call)/]		
		// Function call
		AthenaV3::getStaticTimeMap().startRecordSample("[current_proto.name/]::[call.fctName.name/], call function");
		try
		{
			_[call.fctName.name/]([getFunctionCallSignature(call)/]);
		}
		catch(...)
		{
			__FAIL("error calling user function [call.fctName.name/] in [current_proto.name/] called from interaction [call.fctName.name/].");
		}
		AthenaV3::getStaticTimeMap().endRecordSample("[current_proto.name/]::[call.fctName.name/], call function");
	}
	// Time measurement
	AthenaV3::getStaticTimeMap().endRecordSample("[current_proto.name/]::[call.fctName.name/]");
}
[/template]

[template private generateEvents(project : Project, current_proto : prototypeDeclaration)]
[let events : Sequence(eventDeclaration) = getEvents(project, current_proto)]
[for(event : eventDeclaration | events)]
[generateEvent(current_proto, event)/]
[/for]
[/let]
[/template]

[template private generateEvent(current_proto : prototypeDeclaration, event : eventDeclaration)]
bool [current_proto.name/]::event_[event.name/](const long& icycle)
{
	bool result = true;
	[for (cond : eventCondition | event.conditions)]
	result = result && [getCondition(cond)/];
	[/for]
	return result;
}
[/template]

[template private generateReferences(project : Project, current_proto : prototypeDeclaration)]
[let refs : Sequence(referenceDeclaration) = getReferences(project, current_proto)]
[for(ref : referenceDeclaration | refs)]
[generateReference(current_proto, ref)/]
[/for]
[/let]
[/template]

[template private generateReference(current_proto : prototypeDeclaration, ref : referenceDeclaration)]
// up? =  [ref.upway/], path = [getStringFromQualifiedName(ref.name)/]
const [ref.typeName.name/]& [current_proto.name/]::get_[getReferenceName(ref)/](const long& icycle)
{
	return [getReferenceName(ref)/]->getRead(icycle);
}

[ref.typeName.name/]& [current_proto.name/]::get_[getReferenceName(ref)/]_write(const long& icycle)
{
	return [getReferenceName(ref)/]->getWrite(icycle);
}

void [current_proto.name/]::set_[getReferenceName(ref)/](const long& icycle, const [ref.typeName.name/]& data)
{
	[getReferenceName(ref)/]->write(icycle,data);
}
[/template]