[comment encoding = UTF-8 /]
[module valueTypeImpls('http://www.xtext.org/AthenaDSL')/]

[import org::eclipse::papyrus::generators::xtext::athena::vle::main::DSLQueries /]

[template public valueTypeImpls(project : Project)]
	
[file ('generated/src/TypeDefs_Values.cc', false, 'UTF-8')] 
// 
// Includes ----------------------------------------------------------------------
// 

#include <sstream>
#include <iomanip>
#include <boost/lexical_cast.hpp>
#include <iostream>
#include <vle/utils/Tools.hpp>

#include "TypeDefs_Values.h"

using namespace std;

//
namespace generated
{

//  
// Data type implementations ----------------------------------------------------------
//

	[for (type : DataType | project.types)]
// -------------------------------------------------------- [type.name/]
		[if (isBasicType(type))]
[processBasicType(type.oclAsType(basicType))/]
		[elseif (isArrayType(type))]
[processArrayType(type.oclAsType(arrayType))/]
		[elseif (isVectorType(type))] 
[processVectorType(type.oclAsType(vectorType))/]
		[elseif (isMapType(type))]
[processMapType(type.oclAsType(mapType))/]
		[elseif (isStructType(type))]
[processStructType(type.oclAsType(structType))/]
		[elseif (isDefineType(type))]
[processDefineType(type.oclAsType(defineType))/]
		[else]
///
/// ERROR [type.name/] is unrecognized by the generator - [type.eClass()/]
///
		[/if]
		
	[/for]

// 
// ------------------------------------------------------------------------------------
//
} // eof namespace generated

[/file]
	
[/template]


[template public processBasicType(type : basicType)]
// basic type [type.name/]
value::Value* [type.name/]_toValue(const [type.name/]& _val) {
	[if(hasVLELanguage(type))]
		[let lng : languageDecl = getVLELanguageDecl(type) ]
			[if(needPointerCast(type))]
	value::Value* val = value::[lng.trans/]::create((int)_val);
			[else]
	value::Value* val = value::[lng.trans/]::create(_val);
			[/if]
		[/let]
	[elseif(hasCPPLanguage(type))]
		[let lng : languageDecl = getCPPLanguageDecl(type) ]
	value::Value* val = [lng.trans/](_val);		
		[/let]
	[/if]
	return val;
}

[type.name/] [type.name/]_fromValue(const value::Value* _node, const [type.name/]& _initialValue) {
	[if(hasVLELanguage(type))]
		[let lng : languageDecl = getVLELanguageDecl(type) ]
	if(_node != NULL)
		[if(isEnumeration(type))]
		return static_cast<[type.name/]>(_node->to[lng.trans/]().value());
		[else]
			[if(needPointerCast(type))]
		return ([type.name/])_node->to[lng.trans/]().value();
			[else]
		return _node->to[lng.trans/]().value();
			[/if]
		[/if]
	else
		return _initialValue;		
		[/let]
	[elseif(hasCPPLanguage(type))]
		[let lng : languageDecl = getCPPLanguageDecl(type) ]
	if(_node != NULL)
				[if(hasCPPLexicalCast(type))]
					[if(isEnumeration(type))]
		return static_cast<[getCPPLexicalCast(type)/]>(_node);
					[else]
		return boost::lexical_cast<[getCPPLexicalCast(type)/]>(_node);
					[/if]
				[else]
		return _node->to[lng.trans/]().value;
				[/if]
	else
		return _initialValue;
		[/let]
	[else]
	/* not language define */
	return _initialValue;
	[/if]
}
[/template]


[template public processArrayType(array : arrayType)]
// [array.name/] is an array of [getArrayDatatypeName(array)/]
[let type : DataType = getBaseType(array.typename)]
value::Value* [array.name/]_toValue(const [array.name/]& _val) {	
	[if (isAOneDimensionArray(array))]
	value::Set* set = value::Set::create();
	if(set != NULL) 
	{
		for(unsigned int i = 0; i < [getArraySizeOperator(array)/]; i++) 
		{
			[if (isStructType(type)) ]
			set->add([type.name/]_toValue((*_val)['['/]i[']'/])) ;
			[else]
			set->add([type.name/]_toValue([if (isDynamicArray(array))](*_val)[else]_val[/if]['['/]i[']'/])) ;
			[/if]
		}
	}
	return set;
	[else]
	value::Map* map = value::Map::create();
	if(map != NULL)
	{
		for(unsigned int cpt = 0; cpt < [array.indices->size()/]; cpt ++)
		{
			value::Set* set = value::Set::create();
			if(set != NULL)
			{
				for(unsigned int index = 0; index < [getArraySizeOperator(array)/]; index ++)
				{
					set->add([type.name/]_toValue((*_val)['['/]cpt[']'/]['['/]index[']'/])) ;
				}
				map->add(utils::toString(cpt), set);
			}
		}
	}
	return map;
	[/if]
}

void [array.name/]_fromValue(const value::Value* _node,[array.name/]& _val) {
	[if (isAOneDimensionArray(array))]
	const value::Set& set = _node->toSet();
	for(unsigned int i = 0; i < [getArraySizeOperator(array)/]; i++) {
		[if (isStructType(type)) ]
		(*_val)['['/]i[']'/].fromXML(set.get(i)) ; 
		[else]
		[if (isDynamicArray(array))](*_val)[else]_val[/if]['['/]i[']'/] = [type.name/]_fromValue(set.get(i)) ;
		[/if]
	}
	[else]
	const value::Map& map = _node->toMap();
	for(unsigned int cpt = 0; cpt < [array.indices->size()/]; cpt ++)
	{
		std::string key = utils::toString(cpt);
		if(map.exist(key))
		{
			const value::Set& set = map.get(key)->toSet();
			for(unsigned int index = 0; index < [getArraySizeOperator(array)/]; index ++) {
				[if (isStructType(type)) ]
				(*_val)['['/]cpt[']'/]['['/]index[']'/].fromXML(set.get(index)) ; 
				[else]
				(*_val)['['/]cpt[']'/]['['/]index[']'/] = [type.name/]_fromValue(set.get(index)) ;
				[/if]
			}
		}
	}
	[/if]

}
[/let]
[/template]


[template public processVectorType(vector : vectorType)]
// [vector.name/] is a vector of [getVectorDatatypeName(vector)/]
value::Value* [vector.name/]_toValue(const [vector.name/]& _val) {
	[let typename : String = getVectorDatatypeName(vector)]
	value::Set* set = value::Set::create();
	if(set != NULL)
	{
		[vector.name/]::const_iterator it = _val.begin();
		for (;it != _val.end(); it++) {
			set->add([typename/]_toValue(*it)) ;
		}
	}
	return set;
	[/let]
}

void [vector.name/]_fromValue(const value::Value* _node, [vector.name/]& vect) {
	[let typename : String = getVectorDatatypeName(vector)]
	vect.clear();
	const value::Set& set = _node->toSet();
	for (unsigned int i = 0; i < set.size(); i++) {
		const value::Value* val = set.get(i);
		[typename/] _val;
		[typename/]_fromValue(val, _val) ;
		vect.push_back(_val);
	}
	[/let]
}

[comment][vector.name/] [vector.name/]_fromValue(const value::Value* _node) {
	[let typename : String = getVectorDatatypeName(vector)]
	[vector.name/] _[vector.name/];
	const value::Set& _xn = _node->toSet();
	for (unsigned int _i=0; _i<_xn.size(); _i++) {
		const value::Value* _n = _xn.get(_i);
		[typename/] _val;
		[if (isStructType(vector.typename))]
		[typename/]_fromValue(_n, _val) ;
		[else]
		_val = [typename/]_fromValue(_n) ;
  		[/if]	
		_[vector.name/].push_back(_val);
	}
	return _[vector.name/];
	[/let]
}[/comment]
[/template]


[template public processMapType(map : mapType)]
// [map.name/] is a map with key type [getMapKeyTypeName(map)/] and value type [getMapValueTypeName(map)/]
	[let keytypename : String = getMapKeyTypeName(map)]
	[let datatypename : String = getMapValueTypeName(map)]
value::Value* [map.name/]_toValue(const [map.name/]& _val) {
	value::Map* map = value::Map::create();
	if(map != NULL)
	{
		[map.name/]::const_iterator it = _val.begin();
		for (;it != _val.end(); it++) {
			const std::string& key = boost::lexical_cast<std::string>((*it).first);
			const value::Value& val = *[datatypename/]_toValue((*it).second);
			map->add(key, val);
		}
	}
	return map;

}

void [map.name/]_fromValue(const value::Value* _node, [map.name/]& _map) {
[comment]	[map.name/] _[map.name/];[/comment]
	const value::Map& map = _node->toMap();
	for (value::Map::const_iterator it = map.begin(); it != map.end(); it++) {
		const [map.keytype.name/]& key = static_cast<[map.keytype.name/]>(map.getInt((*it).first));
		const value::Value* val = (*it).second;

		[datatypename/]_fromValue(val, _map['['/]key[']'/]);
	}
[comment]	return _[map.name/];[/comment]
}

[comment][map.name/] [map.name/]_fromValue(const value::Value* _node) {
	[map.name/] _[map.name/];
	const value::Map& _xn = _node->toMap();
	for (value::Map::const_iterator it=_xn.begin(); it!=_xn.end(); it++) {
[comment]		const std::string& key = (*it).first;[/comment]
		const [map.keytype.name/]& key = static_cast<[map.keytype.name/]>(_xn.getInt((*it).first));
		const value::Value* _n = (*it).second;
[comment]		_[map.name/]['['/]key[']'/]=[datatypename/]_fromValue(_n);[/comment]
		[comment][if(isContainer(map.valtype))]
		_[map.name/]['['/]key[']'/]=[datatypename/]_fromValue(_n);
		[else][/comment]
		[datatypename/]_fromValue(_n, _[map.name/]['['/]key[']'/]);
		[comment][/if][/comment]
	}
	return _[map.name/];
}[/comment]
	[/let]
	[/let]
[/template]


[template public processStructType(struct : structType)]
// [struct.name/] is a structure
value::Value* [struct.name/]_toValue(const [struct.name/]& _val) {
	value::Map* map = value::Map::create();
	if(map != NULL)
	{
	[for (param : structElement | struct.parameters)]
	[if (isUnionType(param.typename))]
		// unauthorized union type for [param.name/]
	[else]
		map->add("[param.name/]",[param.typename.name/]_toValue(_val.[param.name/]));
	[/if]
	[/for]
	}
	return map;
}

void [struct.name/]_fromValue(const value::Value* _node, [struct.name/]& _val) {
	const value::Map& map = _node->toMap();
	[for (param : structElement | struct.parameters)]
		[let ptype : DataType = getBaseType(param.typename)]
			[if (isBasicType(ptype))]
				[if (param.hasInitValue)]
	_val.[param.name/] = [ptype.name/]_fromValue(map.get("[param.name/]"), [param.initValue/]);
				[else]
	_val.[param.name/] = [ptype.name/]_fromValue(map.get("[param.name/]"));
				[/if]
			[elseif (isArrayType(ptype) or isStructType(ptype) or isVectorType(ptype) or isMapType(ptype))]
	[ptype.name/]_fromValue(map.get("[param.name/]"), _val.[param.name/]);
			[elseif (isUnionType(ptype))]
	// unauthorized union type for [param.name/]
			[else]
	_val.[param.name/] = [ptype.name/]_fromValue(map.get("[param.name/]"));
			[/if]
		[/let]
	[/for]
}
[/template]

[template public processDefineType(define : defineType)]
// [define.name/] is a [getDefineTypeName(define)/]
[let type : DataType = getBaseType(define)]
value::Value* [define.name/]_toValue(const [define.name/]& _val) {
	return [type.name/]_toValue(_val);
}
[if (isStructType(type) or isArrayType(type))]
void [define.name/]_fromValue(const value::Value* _node, [define.name/]& _val) {
	[type.name/]_fromValue(_node, _val);
[else]
[define.name/] [define.name/]_fromValue(const value::Value* _node) {
	return [type.name/]_fromValue(_node);
[/if]
}
[/let]
[/template]



