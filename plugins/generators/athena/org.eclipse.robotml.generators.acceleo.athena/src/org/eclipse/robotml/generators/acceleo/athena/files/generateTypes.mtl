[comment encoding = UTF-8 /]
[module generateTypes('http://www.eclipse.org/uml2/3.0.0/UML')/]

[import org::eclipse::robotml::generators::acceleo::athena::mmqueries::MMSpecificQueries /]

[template public generateTypes(model : Model)]
[comment @main /]

[let types : Sequence(NamedElement) = getSortedDataType(model)]
[for(type : NamedElement | types)]
[if(isBasicType(type))]
[generateBasicType(type)/]
[elseif(isEnumerationType(type))]
[generateEnumerationType(type)/]
[elseif(isStructuredType(type))]
[generateStructuratedType(type)/]
[elseif(isContainerType(type))]
[generateContainerType(type)/]
[elseif(isDefineType(type))]
[generateDefineType(type)/]
[elseif(isUnionType(type))]
[generateUnionType(type)/]
[else]
//Unknown type : [type.name/]
[/if]
[/for]
[generateValidity(types)/]
[/let]
[/template]

[comment]Basic datatype generation[/comment]
[template private generateBasicType(ne : NamedElement)]
[if(hasComment(ne))]
[getCommentFromElement(ne)/]
[/if]
basic [ne.name/] begin
	[getAthenaDataTypeDeclaration(ne)/]
end
[/template]

[comment]Enumeration generation[/comment]
[template private generateEnumerationType(ne : NamedElement)]
[if(hasComment(ne))]
[getCommentFromElement(ne)/]
[/if]
[let enum : Enumeration = ne.oclAsType(Enumeration)]
basic [ne.name/] begin
language CPP : "enum {
[let literals : OrderedSet(EnumerationLiteral) = enum.ownedLiteral]
[for(literal : EnumerationLiteral | literals)]
[literal.name/]=[if((literal.specification = null) =(false) )][literal.specification.integerValue()/][/if][if(literals->indexOf(literal) < literals->size())],[/if]
[/for]
}" = "[literals->first().name/]"
[/let]
language VLE : "Integer" = "0"
lexicalCast CPP : "unsigned int"
end
[/let]
[/template]

[comment]Structured datatype generation[/comment]
[template private generateStructuratedType(ne : NamedElement)]
[if(hasComment(ne))]
[getCommentFromElement(ne)/]
[/if]
[let struct : DataType = ne.oclAsType(DataType)]
struct [ne.name/] begin
[for(prop : Property | struct.attribute)]
[prop.type.name/] [prop.name/]
[/for]
[/let]
end
[/template]

[comment][template private generateUnknownType(model : Model)]
[let types : Sequence(NamedElement) = getUnknownDataTypes(model)]
	[for(type : NamedElement | types)]
		[let data : DataType = type.oclAsType(DataType)]
// [data.name/] == > unknown type !!!
		[/let]
	[/for]
[/let]
[/template][/comment]

[comment]Container type generartion (array, vector and map)[/comment]
[template private generateContainerType(ne : NamedElement)]
[if(hasComment(ne))]
[getCommentFromElement(ne)/]
[/if]
[getContainerTypeDeclaration(ne)/]
[/template]

[comment]Definition type generation[/comment]
[template private generateDefineType(ne : NamedElement)]
[if(hasComment(ne))]
[getCommentFromElement(ne)/]
[/if]
[let dt : DataType = ne.oclAsType(DataType)]
[for(prop : Property | dt.attribute)]
define [type.name/] is [prop.type.name/]
[/for]
[/let]
[/template]

[comment]Validity generation[/comment]
[template private generateValidity(types : Sequence(NamedElement))]
[for(type : NamedElement | types)]
[if(hasDataTypeValidity(type))]
validity [type.name/] is [getDataTypeValidity(type)/]
[/if]
[/for]
[/template]

[comment]Union type generation[/comment]
[template private generateUnionType(ne : NamedElement)]
[if(hasComment(ne))]
[getCommentFromElement(ne)/]
[/if]
union [ne.name/] begin
//Not defined in the model!
end
[/template]
